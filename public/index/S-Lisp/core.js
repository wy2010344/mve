{
  "lib-path/g_Lib/better/if-run.lisp": "[\r\n    if-run [\r\n        cpp [\r\n            `可以调用IfFunc，但中间retain\\release次数比较多`\r\n            run \"\r\n                Base * fun=IfFun::base_run(args);\r\n                Base * b=NULL;\r\n                if(fun!=NULL){\r\n                    b=static_cast<Function*>(fun)->exec(NULL);\r\n                    if(b!=NULL){\r\n                        b->eval_release();\r\n                    }\r\n                }\r\n                return b;\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Object o=IfFun.base_run(args);\r\n                if(o==null){\r\n                    return null;\r\n                }else{\r\n                    return (o as Function).exec(null);\r\n                }\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var o=IfFun.base_run(args);\r\n                if(o==null){\r\n                    return null;\r\n                }else{\r\n                    return o.exec(null);\r\n                }\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        o=IfFun.base_run(args)\r\n        if o==None:\r\n            return None\r\n        else:\r\n            return o.exe(None)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (a b c) args)\r\n            (let x (default (if a b c)))\r\n            (x)\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/better/index.lisp": "[\r\n    quote [\r\n        cpp [\r\n            run \"\r\n                return args->First();\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                return args.First();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return args.First();\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                return [args First];\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        return args.First()\r\n            \"\r\n        ]\r\n        lisp {\r\n            (first args)\r\n        }\r\n    ]\r\n\r\n\tlist [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n                return args;\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return args;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return args;\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return args;\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args\r\n            \"\r\n        ]\r\n\t\tlisp {\r\n\t\t\targs\r\n\t\t}\r\n\t]\r\n\r\n    kvs-find1st [\r\n        cpp [\r\n            run \"\r\n                Node* kvs_map=static_cast<Node*>(args->First());\r\n                args=args->Rest();\r\n                String* key=static_cast<String*>(args->First());\r\n                return kvs::find1st(kvs_map,key);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Node<Object> kvs=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                String key=args.First() as String;\r\n                return Node<Object>.kvs_find1st(kvs,key);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var kvs=args.First();\r\n                args=args.Rest();\r\n                var key=args.First();\r\n                return lib.s.kvs_find1st(kvs,key);\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                SNode* kvs=(SNode*)[args First];\r\n                args=[args Rest];\r\n                NSString* key=(NSString*)[args First];\r\n                return [SNode kvs_find1stFrom:kvs of:key];\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        kvs=args.First()\r\n        args=args.Rest()\r\n        key=args.First()\r\n        return Node.kvs_find1st(kvs,key)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (key kvs) args find1st this)\r\n            (let (k v ...kvs) args)\r\n            (if-run (str-eq k key)\r\n                {v}\r\n                {(find1st key kvs)}\r\n            )\r\n        }\r\n    ]\r\n    \r\n    kvs-extend [\r\n        cpp [\r\n            run \"\r\n                String* key=static_cast<String*>(args->First());\r\n                args=args->Rest();\r\n                Base* val=args->First();\r\n                args=args->Rest();\r\n                Node* kvs_map=static_cast<Node*>(args->First());\r\n                return kvs::extend(key,val,kvs_map);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                String key=args.First() as String;\r\n                args=args.Rest();\r\n                Object value=args.First();\r\n                args=args.Rest();\r\n                Node<Object> kvs=args.First() as Node<Object>;\r\n                return Node<Object>.kvs_extend(key,value,kvs);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var key=args.First();\r\n                args=args.Rest();\r\n                var value=args.First();\r\n                args=args.Rest();\r\n                var kvs=args.First();\r\n                return lib.s.kvs_extend(key,value,kvs);\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                NSString* key=(NSString*)[args First];\r\n                args=[args Rest];\r\n                NSObject* value=[args First];\r\n                args=[args Rest];\r\n                SNode* kvs=(SNode*)[args First];\r\n                return [SNode kvs_extendKey:key value:value kvs:kvs];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        key=args.First()\r\n        args=args.Rest()\r\n        value=args.First()\r\n        args=args.Rest()\r\n        kvs=args.First()\r\n        return Node.kvs_extend(key,value,kvs)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (k v kvs) args)\r\n            (extend k (extend v kvs))\r\n        }\r\n    ]\r\n    \r\n    type? [\r\n        `可以用type实现，就不一一枚举了`\r\n        cpp [\r\n            run \"\r\n                Base *b=args->First();\r\n                args=args->Rest();\r\n                String* real_type=TypeFun::instance()->base_run(b);\r\n                return Bool::trans(real_type->StdStr()==static_cast<String*>(args->First())->StdStr());\r\n            \"\r\n        ]\r\n\r\n        C# [\r\n            run \"\r\n                Object x=args.First();\r\n                args=args.Rest();\r\n                String n=args.First() as String;\r\n                return (TypeFun.base_run(x)==n);\r\n            \"\r\n        ]\r\n\r\n        js [\r\n            run \"\r\n                var x=args.First();\r\n                args=args.Rest();\r\n                var n=args.First();\r\n                return (TypeFun.base_run(x)==n);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        x=args.First()\r\n        args=args.Rest()\r\n        n=args.First()\r\n        return (TypeFun.base_run(x)==n)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (x n) args)\r\n            (str-eq (type x) n)\r\n        }\r\n    ]\r\n\r\n    call [\r\n        cpp [\r\n            run \"\r\n                Function* f=static_cast<Function*>(args->First());\r\n                args=args->Rest();\r\n                Base * b=f->exec(args);\r\n                if(b!=NULL){\r\n                    b->eval_release();\r\n                }\r\n                return b;\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Function f=args.First() as Function;\r\n                args=args.Rest();\r\n                return f.exec(args);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var run=args.First();\r\n                args=args.Rest();\r\n                return run.exec(args);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        run=args.First()\r\n        args=args.Rest()\r\n        return run.exe(args)\r\n            \"\r\n        ]\r\n        list {\r\n            (let (f ...args) args)\r\n            (apply f args)\r\n        }\r\n    ]\r\n    != [\r\n        alias MNotEqFun\r\n        cpp [\r\n            run \"\r\n                return Bool::trans(!MEqFun::base_run(args));\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                return !MEqFun.base_run(args);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return !MEqFun.base_run(args);\r\n            \"\r\n        ]\r\n        python[\r\n            run \"\r\n        return (not MEqFun.base_run(args))\r\n            \"\r\n        ]\r\n        lisp {\r\n            (not (apply = args))\r\n        }\r\n    ]\r\n\r\n    empty-fun [\r\n        cpp [\r\n            run \"\r\n                return NULL;\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                return null;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return null;\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return None\r\n            \"\r\n        ]\r\n        lisp {}\r\n    ]\r\n    default [\r\n        cpp [\r\n            run \"\r\n                Base * v=args->First();\r\n                if(v!=NULL){\r\n                    return v;\r\n                }else{\r\n                    args=args->Rest();\r\n                    Base * d=args->First();\r\n                    return d;\r\n                }\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Object v=args.First();\r\n                if(v!=null){\r\n                    return v;\r\n                }else{\r\n                    args=args.Rest();\r\n                    return args.First();\r\n                }\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var v=args.First();\r\n                if(v!=null){\r\n                    return v;\r\n                }else{\r\n                    args=args.Rest();\r\n                    return args.First();\r\n                }\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        v=args.First()\r\n        if v!=None:\r\n            return v\r\n        else:\r\n            args=args.Rest()\r\n            return args.First()\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (a d) args)\r\n            (if (exist? a) a d)\r\n        }\r\n    ]   \r\n\r\n    len [\r\n        C# [\r\n            run \"\r\n                Node<Object> list=args.First() as Node<Object>;\r\n                if(list!=null){\r\n                    return list.Length();\r\n                }else{\r\n                    return 0;\r\n                }\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var list=args.First();\r\n                if(list){\r\n                    return list.Length();\r\n                }else{\r\n                    return 0;\r\n                }\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        list=args.First()\r\n        if list!=None:\r\n            return list.Length()\r\n        else:\r\n            return 0\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (cs) args)\r\n            (if-run (exist? cs)\r\n                {\r\n                    (length cs)\r\n                }\r\n                {0}\r\n            )\r\n        }\r\n    ]\r\n\r\n    indexOf [\r\n        `默认只找第一个，假设无重复，如果想找所有的，另定义方法`\r\n        cpp [\r\n            run \"\r\n                Node* vs=static_cast<Node*>(args->First());\r\n                args=args->Rest();\r\n                Base* k=args->First();\r\n                args=args->Rest();\r\n                Function* eq=EqFun::instance();\r\n                if(args!=NULL){\r\n                    eq=static_cast<Function*>(args->First());\r\n                }\r\n\r\n                int index=-1;\r\n                int flag=0;\r\n                while(vs!=NULL && index==-1){\r\n                    Node* nargs=new Node(vs->First(),new Node(k,NULL));\r\n                    nargs->retain();\r\n                    Bool *b=static_cast<Bool*>(eq->exec(nargs));\r\n                    nargs->release();\r\n                    if(b->Value()){\r\n                        index=flag;\r\n                    }else{\r\n                        vs=vs->Rest();\r\n                        flag++;\r\n                    }\r\n                    b->release();\r\n                }\r\n                if(index==-1){\r\n                    return NULL;\r\n                }else{\r\n                    return new Int(index);\r\n                }\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Node<Object> vs=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                Object k=args.First();\r\n                args=args.Rest();\r\n                Function eq=EqFun.instance();\r\n                if(args!=null){\r\n                    eq=args.First() as Function;\r\n                }\r\n\r\n                int index=-1;\r\n                int flag=0;\r\n                while(vs!=null && index==-1){\r\n                    if((bool)eq.exec(Node<Object>.list(vs.First(),k))){\r\n                        index=flag;\r\n                    }else{\r\n                        vs=vs.Rest();\r\n                        flag++;\r\n                    }\r\n                }\r\n                if(index==-1){\r\n                    return null;\r\n                }else{\r\n                    return index;\r\n                }\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        vs=args.First()\r\n        args=args.Rest()\r\n        k=args.First()\r\n        args=args.Rest()\r\n        eq=None\r\n        if args!=None:\r\n            eq=args.First()\r\n        else:\r\n            eq=EqFun()\r\n        index=-1\r\n        flag=0\r\n        while (vs!=None and index==-1):\r\n            if eq.exe(Node.list(vs.First(),k)):\r\n                index=flag\r\n            else:\r\n                vs=vs.Rest()\r\n                flag=flag+1\r\n        if index==-1:\r\n            return None\r\n        else:\r\n            return index\r\n\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let \r\n                (vs k is_eq) args\r\n                is_eq (default eq)\r\n            )\r\n            (loop \r\n                {\r\n                    (let ((v ...vs) index) args)\r\n                    (if-run (is_eq v k)\r\n                        {\r\n                            (list\r\n                                false\r\n                                index\r\n                            )\r\n                        }\r\n                        {\r\n                            (if-run (exist? vs)\r\n                                {\r\n                                    (list\r\n                                        true\r\n                                        (list\r\n                                            vs\r\n                                            (+ index 1)\r\n                                        )\r\n                                    ) \r\n                                }\r\n                            )\r\n                        }\r\n                    )\r\n                }\r\n                (list vs 0)\r\n            )\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/better/kvs-path.lisp": "[\r\n    kvs-path [\r\n        C# [\r\n            other \"\r\n                public static Object base_run(Node<Object> o,Node<Object> paths)\r\n                {\r\n                    Object value=null;\r\n                    while(paths!=null)\r\n                    {\r\n                        String path=paths.First() as String;\r\n                        value=Node<Object>.kvs_find1st(o,path);\r\n                        paths=paths.Rest();\r\n                        if(paths!=null)\r\n                        {\r\n                            o=value as Node<Object>;\r\n                        }\r\n                    }\r\n                    return value;\r\n                }\r\n            \"\r\n            run \"\r\n                Node<Object> o=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                Node<Object> paths=args.First() as Node<Object>;\r\n                return base_run(o,paths);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var kvs=args.First();\r\n                args=args.Rest();\r\n                var paths=args.First();\r\n                return kvs_path(kvs,paths);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(kvs,paths):\r\n        while paths!=None:\r\n            path=paths.First()\r\n            value=Node.kvs_find1st(kvs,path)\r\n            paths=paths.Rest()\r\n            if paths!=None:\r\n                kvs=value\r\n        return value\r\n            \"\r\n            run \"\r\n        kvs=args.First()\r\n        args=args.Rest()\r\n        paths=args.First()\r\n        return Kvs_pathFun.base_run(kvs,args)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (e paths) args kvs-path this)\r\n            (if-run (exist? paths)\r\n                {\r\n                    (let (path ...paths) paths)\r\n                    (kvs-path \r\n                        (kvs-find1st e path)\r\n                        paths\r\n                    )\r\n                }\r\n                {e}\r\n            )\r\n        }\r\n    ]\r\n    \r\n    kvs-path-run [\r\n        C# [\r\n            run \"\r\n                Node<Object> o=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                Node<Object> paths=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                Function f=Kvs_pathFun.base_run(o,paths) as Function;\r\n                return f.exec(args);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var kvs=args.First();\r\n                args=args.Rest();\r\n                var paths=args.First();\r\n                args=args.Rest();\r\n                return kvs_path(kvs,paths).exec(args);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        kvs=args.First()\r\n        kvs=kvs.Rest()\r\n        paths=args.First()\r\n        args=args.Rest()\r\n        return Kvs_pathFun.base_run(kvs,paths).exe(args)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (e paths ...ps) args)\r\n            (apply (kvs-path e paths) ps)\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/better/loop.lisp": "[\r\n    loop [\r\n        `\r\n        列表的遍历有reduce，但非列表的递归调用会报错，用宿主语言的while语句优化一下。\r\n        reduce也可以用loop来实现。\r\n        loop可以说是所有尾递归优化的根\r\n\r\n        进一步改造，init不是一个值，是剩下的所有值\r\n        `\r\n        cpp [\r\n            run \"\r\n                Function * f=static_cast<Function*>(args->First());\r\n                args=args->Rest();\r\n                if(args!=NULL){\r\n                    args->retain();/*第一次作参数，需要retain*/\r\n                }\r\n                bool will=true;\r\n                while(will){\r\n                    Node* o=static_cast<Node*>(f->exec(args));\r\n                    if(args!=NULL){\r\n                        args->release();/*每次当完参数，需要release*/\r\n                    }\r\n                    will=static_cast<Bool*>(o->First())->Value();\r\n                    args=o->Rest();\r\n                    if(args!=NULL){\r\n                        args->retain();/*保持在o->release时不销毁，同时作为下一次函数执行的参数也需要retain*/\r\n                    }\r\n                    o->release();\r\n                };\r\n                if(args!=NULL){\r\n                    args->eval_release();\r\n                }\r\n                return args;\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Function f=args.First() as Function;\r\n                args=args.Rest();\r\n                bool will=true;\r\n                while(will){\r\n                    args=f.exec(args) as Node<Object>;\r\n                    will=(bool)(args.First());\r\n                    args=args.Rest();\r\n                }\r\n                return args;\r\n            \"\r\n        ]\r\n\r\n        js [\r\n            run \"\r\n                var f=args.First();\r\n                args=args.Rest();\r\n                var will=true;\r\n                while(will){\r\n                    args=f.exec(args);\r\n                    will=args.First();\r\n                    args=args.Rest();\r\n                }\r\n                return args;\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        f=args.First()\r\n        args=args.Rest()\r\n        will=True \r\n        while will:\r\n            args=f.exe(args)\r\n            will=args.First()\r\n            args=args.Rest()\r\n        return args\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (f ...init) args loop this)\r\n            (let (will ...init) (apply f init))\r\n            (if-run will\r\n                {\r\n                    (apply loop (extend f init))\r\n                }\r\n                {init}\r\n            )\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/better/pip.lisp": "[\r\n\t`管道，类似于减法`\r\n\tpip [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n\t\t\t\tBase* o=args->First();\r\n\t\t\t\targs=args->Rest();\r\n\t\t\t\twhile(args!=NULL){\r\n\t\t\t\t\tFunction* f=static_cast<Function*>(args->First());\r\n\t\t\t\t\targs=args->Rest();\r\n\t\t\t\t\tNode* n_args=new Node(o,NULL);\r\n\t\t\t\t\tn_args->retain();\r\n\t\t\t\t\to=f->exec(n_args);\r\n\t\t\t\t\tn_args->release();\r\n\t\t\t\t\tif(o!=NULL){\r\n\t\t\t\t\t\to->eval_release();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn o;\r\n\t\t\t\"\r\n\t\t]\r\n\t\tC# [\r\n\t\t\trun \"\r\n\t\t\t\tObject o=args.First();\r\n\t\t\t\targs=args.Rest();\r\n\t\t\t\twhile(args!=null){\r\n\t\t\t\t\tFunction f=args.First() as Function;\r\n\t\t\t\t\targs=args.Rest();\r\n\t\t\t\t\to=f.exec(Node<Object>.extend(o,null));\r\n\t\t\t\t}\r\n\t\t\t\treturn o;\r\n\t\t\t\"\r\n\t\t]\r\n\t\tjs [\r\n\t\t\trun \"\r\n\t\t\t\tvar o=args.First();\r\n\t\t\t\targs=args.Rest();\r\n\t\t\t\twhile(args!=null){\r\n\t\t\t\t\tvar f=args.First();\r\n\t\t\t\t\targs=args.Rest();\r\n\t\t\t\t\to=f.exec(lib.s.list(o));\r\n\t\t\t\t}\r\n\t\t\t\treturn o;\r\n\t\t\t\"\r\n\t\t]\r\n\t\tpython [\r\n\t\t\trun \"\r\n\t\to=args.First()\r\n\t\targs=args.Rest()\r\n\t\twhile args!=None:\r\n\t\t\tf=args.First()\r\n\t\t\targs=args.Rest()\r\n\t\t\to=f.exe(Node.list(o,None))\r\n\t\treturn o\r\n\t\t\t\"\r\n\t\t]\r\n\t\tlisp {\r\n\t\t\t(first\r\n\t\t\t\t(apply loop \r\n\t\t\t\t\t(extend\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (x f ...xs) args)\r\n\t\t\t\t\t\t\t(if-run (empty? xs)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(list\r\n\t\t\t\t\t\t\t\t\t\tfalse\r\n\t\t\t\t\t\t\t\t\t\t(f x)\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(extend \r\n\t\t\t\t\t\t\t\t\t\ttrue \r\n\t\t\t\t\t\t\t\t\t\t(extend (f x) xs)\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\targs\t\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t}\r\n\t]\r\n]\r\n",
  "lib-path/g_Lib/better/reduce.lisp": "[\r\n\t`就是reduce-left`\r\n    reduce [\r\n        cpp [\r\n            run \"\r\n                Node *list=static_cast<Node*>(args->First());\r\n                args=args->Rest();\r\n                Function *f=static_cast<Function*>(args->First());\r\n                args=args->Rest();\r\n                Base * init=args->First();\r\n                while(list!=NULL){\r\n                    Base * x=list->First();\r\n                    Node *nargs=new Node(init,new Node(x,NULL));\r\n                    nargs->retain();\r\n                    Base* n_init=f->exec(nargs);\r\n                    nargs->release();\r\n                    if(n_init!=NULL){\r\n                        n_init->eval_release();\r\n                    }\r\n                    init=n_init;\r\n                    list=list->Rest();\r\n                }\r\n                return init;\r\n            \"\r\n        ]\r\n        C# [\r\n            other \"\r\n            public static Object base_run(Node<Object> list,Node<Object> args){\r\n\r\n                Function f = args.First() as Function;\r\n                args = args.Rest();\r\n                Object init = args.First();\r\n                while (list != null)\r\n                {\r\n                    Object x = list.First();\r\n                    list = list.Rest();\r\n                    Node<Object> nargs = Node<Object>.list(init, x);\r\n                    init = f.exec(nargs);\r\n                }\r\n                return init;\r\n            }\r\n            \"\r\n            run \"\r\n                Node<Object> list = args.First() as Node<Object>;\r\n                args = args.Rest();\r\n                return base_run(list,args);\r\n            \"\r\n        ]\r\n\r\n        js [\r\n            other \"\r\n            ReduceFun.base_run=function(list,args){\r\n                var f=args.First();\r\n                args=args.Rest();\r\n                var init=args.First();\r\n                while(list!=null){\r\n                    var x=list.First();\r\n                    list=list.Rest();\r\n                    var nargs=lib.s.list(init,x);\r\n                    init=f.exec(nargs);\r\n                }\r\n                return init;\r\n            }\r\n            \"\r\n            run \"\r\n                var list=args.First();\r\n                args=args.Rest();\r\n                return ReduceFun.base_run(list,args);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(list,args):\r\n        f=args.First()\r\n        args=args.Rest()\r\n        init=args.First()\r\n        while list!=None:\r\n            x=list.First()\r\n            list=list.Rest()\r\n            nargs=Node.list(init,x)\r\n            init=f.exe(nargs)\r\n        return init\r\n            \"\r\n            run \"\r\n        list=args.First()\r\n        args=args.Rest()\r\n        return ReduceFun.base_run(list,args)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (xs run init) args reduce this)\r\n            (if-run (exist? xs)\r\n                {\r\n                    (let (x ...xs) xs)\r\n                    (let init (run init x))\r\n                    (reduce xs run init)\r\n                }\r\n                {init}\r\n            )\r\n        }\r\n    ]\r\n\r\n    reduce-right [\r\n        C# [\r\n            run \"\r\n                Node<Object> list = args.First() as Node<Object>;\r\n                list=ReverseFun.base_run(list);\r\n                args = args.Rest();\r\n                return ReduceFun.base_run(list,args);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var list=args.First();\r\n                list=ReverseFun.base_run(list);\r\n                args = args.Rest();\r\n                return ReduceFun.base_run(list,args);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        list=args.First()\r\n        list=ReverseFun.base_run(list)\r\n        args=args.Rest()\r\n        return ReduceFun.base_run(list,args)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (xs run init) args reduce-right this)\r\n            (if-run (exist? xs)\r\n                {\r\n                    (let (x ...xs) xs)\r\n                    (run \r\n                        (reduce-right xs run  init)\r\n                        x\r\n                    )\r\n                }\r\n                { init }\r\n            )\r\n        }\r\n    ]\r\n\r\n    kvs-reduce [\r\n        C# [\r\n            other \"\r\n            public static Object base_run(Node<Object> kvs,Node<Object> args){\r\n                Function f = args.First() as Function;\r\n                args = args.Rest();\r\n                Object init = args.First();\r\n                while (kvs != null)\r\n                {\r\n                    Object key = kvs.First();\r\n                    kvs = kvs.Rest();\r\n                    Object value = kvs.First();\r\n                    kvs = kvs.Rest();\r\n                    Node<Object> nargs = Node<Object>.list(init,value,key);\r\n                    init = f.exec(nargs);\r\n                }\r\n                return init;\r\n            }\r\n            \"\r\n            run \"\r\n                Node<Object> kvs = args.First() as Node<Object>;\r\n                args = args.Rest();\r\n                return base_run(kvs,args);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n            Kvs_reduceFun.base_run=function(kvs,args){\r\n                var f=args.First();\r\n                args=args.Rest();\r\n                var init=args.First();\r\n                while(kvs!=null){\r\n                    var key=kvs.First();\r\n                    kvs=kvs.Rest();\r\n                    var value=kvs.First();\r\n                    kvs=kvs.Rest();\r\n                    var nargs=lib.s.list(init,value,key);\r\n                    init=f.exec(nargs);\r\n                }\r\n                return init;\r\n            }\r\n            \"\r\n            run \"\r\n                var kvs=args.First();\r\n                args=args.Rest();\r\n                return Kvs_reduceFun.base_run(kvs,args);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(kvs,args):\r\n        f=args.First()\r\n        args=args.Rest()\r\n        init=args.First()\r\n        while kvs!=None:\r\n            key=kvs.First()\r\n            kvs=kvs.Rest()\r\n            value=kvs.First()\r\n            kvs=kvs.Rest()\r\n            nargs=Node.list(init,value,key)\r\n            init=f.exe(nargs)\r\n        return init\r\n            \"\r\n            run \"\r\n        kvs=args.First()\r\n        args=args.Rest()\r\n        return Kvs_reduceFun.base_run(kvs,args)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (kvs run init) args kvs-reduce this)\r\n            (if-run (exist? kvs)\r\n                {\r\n                    (let (k v ...kvs) kvs)\r\n                    (let init (run init v k))\r\n                    (kvs-reduce kvs run init)\r\n                }\r\n                {init}\r\n            )\r\n        }\r\n    ]\r\n\r\n    kvs-reduce-right [\r\n        C# [\r\n            run \"\r\n                Node<Object> kvs = args.First() as Node<Object>;\r\n                kvs=Kvs_reverseFun.base_run(kvs);\r\n                args = args.Rest();\r\n                return Kvs_reduceFun.base_run(kvs,args);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var kvs=args.First();\r\n                kvs=Kvs_reverseFun.base_run(kvs);\r\n                args=args.Rest();\r\n                return Kvs_reduceFun.base_run(kvs,args);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        kvs=args.First()\r\n        kvs=Kvs_reverseFun.base_run(kvs)\r\n        args=args.Rest()\r\n        return Kvs_reduceFun.base_run(kvs,args)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (kvs run init) args kvs-reduce-right this)\r\n            (if-run (exist? kvs)\r\n                {\r\n                    (let (k v ...kvs) kvs)\r\n                    (run\r\n                        (kvs-reduce-right kvs run init)\r\n                        v\r\n                        k\r\n                    )\r\n                }\r\n                { init }\r\n            )\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/better/reverse.lisp": "[\r\n    reverse [\r\n        cpp [\r\n            run \"\r\n                Node * list=static_cast<Node*>(args->First());\r\n                Node *r=NULL;\r\n                while(list!=NULL){\r\n                    r=new Node(list->First(),r);\r\n                    list=list->Rest();\r\n                }\r\n                return r;\r\n            \"\r\n        ]\r\n        C# [\r\n            other \"\r\n            public static Node<Object> base_run(Node<Object> list){\r\n                Node<Object> r=null;\r\n                Node<Object> tmp=list;\r\n                while(tmp!=null){\r\n                    Object v=tmp.First();\r\n                    r=Node<Object>.extend(v,r);\r\n                    tmp=tmp.Rest();\r\n                }\r\n                return r;\r\n            }\r\n            \"\r\n            run \"\r\n                return base_run(args.First() as Node<Object>);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n            ReverseFun.base_run=function(list){\r\n                return lib.s.reverse(list);\r\n            };\r\n            \"\r\n            run \"\r\n                return ReverseFun.base_run(args.First());\r\n            \"\r\n        ]\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(list):\r\n        return Node.reverse(list)\r\n            \"\r\n            run \"\r\n        return ReverseFun.base_run(args.First())\r\n            \"\r\n        ]\r\n        `可以用lisp实现，有点麻烦的样子`\r\n        lisp {\r\n            (let (xs) args)\r\n            (reduce \r\n                xs\r\n                {\r\n                    (let (init x) args)\r\n                    (extend x init)\r\n                }\r\n                []\r\n            )\r\n        }\r\n    ]\r\n\r\n    kvs-reverse [\r\n        cpp [\r\n\r\n        ]\r\n        C# [\r\n            other \"\r\n            public static Node<Object> base_run(Node<Object> kvs){\r\n                Node<Object> r=null;\r\n                Node<Object> tmp=kvs;\r\n                while(tmp!=null){\r\n                    String key=tmp.First() as String;\r\n                    tmp=tmp.Rest();\r\n                    Object value=tmp.First();\r\n                    tmp=tmp.Rest();\r\n                    r=Node<Object>.kvs_extend(key,value,r);\r\n                }\r\n                return r;\r\n            }\r\n            \"\r\n            run \"\r\n                return base_run(args.First() as Node<Object>);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n            Kvs_reverseFun.base_run=function(kvs){\r\n                var r=null;\r\n                var tmp=kvs;\r\n                while(tmp!=null){\r\n                    var key=tmp.First();\r\n                    tmp=tmp.Rest();\r\n                    var value=tmp.First();\r\n                    tmp=tmp.Rest();\r\n                    r=lib.s.kvs_extend(key,value,r);\r\n                }\r\n                return r;\r\n            };\r\n            \"\r\n            run \"\r\n                return Kvs_reverseFun.base_run(args.First());\r\n            \"\r\n        ]\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(kvs):\r\n        r=None\r\n        tmp=kvs\r\n        while tmp!=None:\r\n            key=tmp.First()\r\n            tmp=tmp.Rest()\r\n            value=tmp.First()\r\n            tmp=tmp.Rest()\r\n            r=Node.kvs_extend(key,value,r)\r\n        return r\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (kvs) args)\r\n            (kvs-reduce \r\n                kvs\r\n                {\r\n                    (let (init v k) args)\r\n                    (kvs-extend k v init)\r\n                }\r\n                []\r\n            )\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/better/split.lisp": "[\r\n    slice-from [\r\n        cpp [\r\n            other \"\r\n            static Node* base_run(Node* list,int i){\r\n                while(i!=0){\r\n                    list=list->Rest();\r\n                    i--;\r\n                }\r\n                return list;\r\n            }\r\n            \"\r\n            run \"\r\n            Node* list=static_cast<Node*>(args->First());\r\n            args=args->Rest();\r\n            int i=static_cast<Int*>(args->First())->Value();\r\n            return base_run(list,i);\r\n            \"\r\n        ]\r\n        C# [\r\n            other \"\r\n            public static Node<Object> base_run(Node<Object> list,int i){\r\n                while(i!=0){\r\n                    list=list.Rest();\r\n                    i--;\r\n                }\r\n                return list;\r\n            }\r\n            \"\r\n            run \"\r\n                Node<Object> list=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                int i=(int)args.First();\r\n                return base_run(list,i);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n            Slice_fromFun.base_run=function(list,i){\r\n                while(i!=0){\r\n                    list=list.Rest();\r\n                    i--;\r\n                }\r\n                return list;\r\n            }\r\n            \"\r\n            run \"\r\n            var list=args.First();\r\n            args=args.Rest();\r\n            var i=args.First();\r\n            return Slice_fromFun.base_run(list,i);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(list,i):\r\n        while i!=0:\r\n            list=list.Rest()\r\n            i=i-1\r\n        return list\r\n            \"\r\n            run \"\r\n        list=args.First()\r\n        args=args.Rest()\r\n        i=args.First()\r\n        return Slice_fromFun.base_run(list,i)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (list i) args offset this)\r\n            (if-run (= i 0) \r\n                { list }\r\n                {\r\n                    (offset (rest list) (- i 1)) \r\n                } \r\n            )\r\n        }\r\n    ]\r\n\r\n    slice-to [\r\n        C# [\r\n            run \"\r\n                Node<Object> list=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                int i=(int)args.First();\r\n\r\n                Node<Object> r=null;\r\n                while(i!=0){\r\n                    r=Node<Object>.extend(list.First(),r);\r\n                    list=list.Rest();\r\n                    i--;\r\n                }\r\n                return ReverseFun.base_run(r);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var list=args.First();\r\n                args=args.Rest();\r\n                var i=args.First();\r\n                var r=null;\r\n                while(i!=0){\r\n                    r=lib.s.extend(list.First(),r);\r\n                    list=list.Rest();\r\n                    i--;\r\n                }\r\n                return ReverseFun.base_run(r);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        list=args.First()\r\n        args=args.Rest()\r\n        i=args.First()\r\n        r=None\r\n        while i!=0:\r\n            r=Node.extend(list.First(),r)\r\n            list=list.Rest()\r\n            i=i-1\r\n        return ReverseFun.base_run(r)\r\n            \"\r\n        ]\r\n        lisp {\r\n            (let (xs to) args slice-to this)\r\n            (if-run (= to 0)\r\n                {[]}\r\n                {\r\n                    (let (x ...xs) xs)\r\n                    (extend x (slice-to xs (- to 1)))\r\n                }\r\n            )\r\n        }\r\n    ]\r\n\r\n    offset [\r\n        `\r\n        offset与slice-from不同，offset是取slice-from的第一个元素\r\n        `\r\n        cpp [\r\n            run \"\r\n            Node* list=static_cast<Node*>(args->First());\r\n            args=args->Rest();\r\n            int i=static_cast<Int*>(args->First())->Value();\r\n            return Slice_fromFun::base_run(list,i)->First();\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Node<Object> list=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                int i=(int)args.First();\r\n                return Slice_fromFun.base_run(args,i).First();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var list=args.First();\r\n                args=args.Rest();\r\n                var i=args.First();\r\n                return Slice_fromFun.base_run(list,i).First()\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        list=args.First()\r\n        args=args.Rest()\r\n        i=args.First()\r\n        return Slice_fromFun.base_run(list,i).First()\r\n            \"\r\n        ]\r\n        lisp {\r\n            (first (apply slice-from args))\r\n        }\r\n    ]\r\n]",
  "lib-path/g_Lib/g_common.lisp": "{\r\n\t(let \r\n\t\t`\r\n\t\t\tk\r\n\t\t\tbuild-cls\r\n\t\t\tbuild-m\r\n\t\t\twrite-result\r\n\t\t`\r\n\t\t(p) args\r\n\t\ttrans_name (load './trans_name.lisp)\r\n\t\tlibs  \r\n\t\t\t(list\r\n\t\t\t\t(load './system/index.lisp)\r\n\t\t\t\t(load './system/toStr.lisp)\r\n\t\t\t\t(load './system/type.lisp)\r\n\t\t\t\t(load './system/math.lisp)\r\n\t\t\t\t(load './system/bool.lisp)\r\n\t\t\t\t(load './system/str.lisp)\r\n\t\t\t\t\r\n\t\t\t\t(load './better/index.lisp)\r\n\t\t\t\t(load './better/if-run.lisp)\r\n\t\t\t\t(load './better/loop.lisp)\r\n\t\t\t\t(load './better/reverse.lisp)\r\n\t\t\t\t(load './better/reduce.lisp)\r\n\t\t\t\t(load './better/kvs-path.lisp)\r\n\t\t\t\t(load './better/pip.lisp)\r\n\t\t\t\t(load './better/split.lisp)\r\n\t\t\t)\r\n\t\t(cls fun)\r\n\t\t\t(reduce-right\r\n\t\t\t\tlibs\r\n\t\t\t\t{\r\n\t\t\t\t\t(let (init lib) args)\r\n\t\t\t\t\t(kvs-reduce-right\r\n\t\t\t\t\t\tlib\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t(init v k) args\r\n\t\t\t\t\t\t\t\tnode (kvs-find1st v p.k)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(if-run (exist? node.run)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t\t\tkey \r\n\t\t\t\t\t\t\t\t\t\t\t(if-run (exist? v.alias)\r\n\t\t\t\t\t\t\t\t\t\t\t\t{v.alias}\r\n\t\t\t\t\t\t\t\t\t\t\t\t{(trans_name k)}\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t(ftype toStr)\r\n\t\t\t\t\t\t\t\t\t\t\t(if-run (exist? v.lisp)\r\n\t\t\t\t\t\t\t\t\t\t\t\t{['p.better-type {(stringify v.lisp)}]}\r\n\t\t\t\t\t\t\t\t\t\t\t\t{['p.in-type {k}]}\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t(let (cls fun) init)\r\n\t\t\t                        (list\r\n\t\t\t                            (extend\r\n\t\t\t                                (str-join\r\n\t\t\t                                    (p.build-cls\r\n\t\t\t                                        [\r\n\t\t\t                                            key 'key\r\n\t\t\t                                            run 'node.run\r\n\t\t\t                                            other 'node.other\r\n\t\t\t                                            type 'ftype\r\n\t\t\t                                            toString 'toStr\r\n\t\t\t                                        ]\r\n\t\t\t                                    )\r\n\t\t\t                                )\r\n\t\t\t                                cls\r\n\t\t\t                            )\r\n\t\t\t                            (extend\r\n\t\t\t                                (str-join\r\n\t\t\t                                    (p.build-m k key)\r\n\t\t\t                                )\r\n\t\t\t                                fun\r\n\t\t\t                            )\r\n\t\t\t                        )\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t{init}\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tinit\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\t[[] []]\r\n\t\t\t)\r\n\t)\r\n\t(p.write-result cls fun)\r\n}",
  "lib-path/g_Lib/g_js_common.lisp": "\r\n(str-join \r\n\t[\r\n\t\t\"\r\n        var or=function(a,b){\r\n            return a||b;\r\n        };\r\n        var and=function(a,b){\r\n            return a&&b;\r\n        };\r\n        var reduce=function(args,func,init) {\r\n            for(var t=args;t!=null;t=t.Rest()){\r\n                init=func(init,t.First());\r\n            }\r\n            return init;\r\n        };\r\n        var compare=function(args,check,func){\r\n            var last=args.First();\r\n            var init=true;\r\n            check(last);\r\n            //mb.log(args.toString())\r\n            for(var t=args.Rest();t!=null;t=t.Rest()){\r\n                var now=t.First();\r\n                check(now);\r\n                init=and(init,func(last,now));\r\n                last=now;\r\n            }\r\n            return init;\r\n        };\r\n        var check_is_number=function(s){\r\n            if(s==0){\r\n                return true;\r\n            }else\r\n            if(s && s.constructor==Number){\r\n                return true;\r\n            }else{\r\n                mb.log(s+\\\"不是合法的数字类型\\\"+s.constructor);\r\n                return false;\r\n            }\r\n        };\r\n        var kvs_path=function(kvs,paths){\r\n            var value=null;\r\n            while(paths!=null){\r\n                var path=paths.First();\r\n                value=lib.s.kvs_find1st(kvs,path);\r\n                paths=paths.Rest();\r\n                kvs=value;\r\n            }\r\n            return value;\r\n        };\r\n        var eq=function(args,check){\r\n            //可用于数字，字符串，实体\r\n            return compare(args,check,function(last,now){\r\n                return (last==now);\r\n            });\r\n        };\r\n\t\t\"\r\n\t]\r\n)",
  "lib-path/g_Lib/system/bool.lisp": "[\r\n    and [\r\n        cpp [\r\n            run \"\r\n                bool init=true;\r\n                Node *t=args;\r\n                while(t!=NULL && init){\r\n                    Bool *b=static_cast<Bool*>(t->First());\r\n                    init=b->Value();\r\n                    t=t->Rest();\r\n                }\r\n                return Bool::trans(init);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                bool ret=true;\r\n                while(args!=null && ret)\r\n                {\r\n                    ret=(bool)args.First();\r\n                    args=args.Rest();\r\n                }\r\n                return ret;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return reduce(args,function(init,v) {\r\n                    return and(init,v);\r\n                },true);\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                BOOL init=YES;\r\n                SNode* t=args;\r\n                while(t!=nil && init){\r\n                    init=[(SBool*)[t First] Value];\r\n                    t=[t Rest];\r\n                }\r\n                return [SBool trans:init];\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        init=True\r\n        t=args\r\n        while (t!=None and init):\r\n            init=t.First()\r\n            t=t.Rest()\r\n        return init\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    or [\r\n        cpp [\r\n            run \"\r\n                bool init=false;\r\n                Node *t=args;\r\n                while(t!=NULL && (!init)){\r\n                    Bool *b=static_cast<Bool*>(t->First());\r\n                    init=b->Value();\r\n                    t=t->Rest();\r\n                }\r\n                return Bool::trans(init);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                bool ret=false;\r\n                while(args!=null && (!ret))\r\n                {\r\n                    ret=(bool)args.First();\r\n                    args=args.Rest();\r\n                }\r\n                return ret;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return reduce(args,function(init,v) {\r\n                    return or(init,v);\r\n                },false);\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                BOOL init=NO;\r\n                SNode* t=args;\r\n                while(t!=nil && (!init)){\r\n                    init=[(SBool*)[t First] Value];\r\n                    t=[t Rest];\r\n                }\r\n                return [SBool trans:init];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        init=False\r\n        t=args\r\n        while(t!=None and (not init)):\r\n            init=t.First()\r\n            t=t.Rest()\r\n        return t\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    not [\r\n        cpp [\r\n            run \"\r\n                Bool *b=static_cast<Bool*>(args->First());\r\n                return Bool::trans(!b->Value());\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                return !(bool)args.First();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return !args.First();\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return [SBool trans:![(SBool*)[args First] Value]];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return (not args.First())\r\n            \"\r\n        ]\r\n    ]\r\n]",
  "lib-path/g_Lib/system/index.lisp": "[\r\n\t`first函数`\r\n\tfirst [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n                return (static_cast<Node *>(args->First()))->First();\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return (args.First() as Node<Object>).First();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var v=args.First();\r\n                return v.First();\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return [(SNode*)[args First] First];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First().First()\r\n            \"\r\n        ]\r\n\t]\r\n\trest [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n\t\t\t\treturn (static_cast<Node *>(args->First()))->Rest();\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return (args.First() as Node<Object>).Rest();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var v=args.First();\r\n                return v.Rest();\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return [(SNode*)[args First] Rest];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First().Rest()\r\n            \"\r\n        ]\r\n\t]\r\n\textend [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n\t\t\t\treturn new Node(args->First(),static_cast<Node*>(args->Rest()->First()));\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return Node<Object>.extend(args.First(),(args.Rest().First() as Node<Object>));\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return lib.s.extend(args.First(),args.Rest().First());\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return [SNode extend:[args First] with:(SNode*)[[args Rest] First]];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return Node.extend(args.First(),args.Rest().First())\r\n            \"\r\n        ]\r\n\t]\r\n\tlength [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n                return new Int(((Node *)args->First())->Length());\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return (args.First() as Node<Object>).Length();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return args.First().Length();\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return [NSNumber numberWithInt:[(SNode*)[args First] Length]];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First().Length()\r\n            \"\r\n        ]\r\n\t]\r\n\r\n    ref-count [\r\n        cpp [\r\n            run \"\r\n                Base *b=args->First();\r\n                return new Int(b->ref_count());\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                return [NSNumber numberWithLong:[[args First] retainCount]-1];\r\n            \"\r\n        ]\r\n    ]\r\n\r\n\t`判断列表为空，应该只支持列表和空才对`\r\n\tempty? [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n                return Bool::trans(args->First()==NULL);\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return args.First()==null;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return (args.First()==null);\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                return [SBool trans:[args First]==nil];\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        return args.First()==None\r\n            \"\r\n        ]\r\n\t]\r\n\texist? [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n                return Bool::trans(args->First()!=NULL);\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                return args.First()!=null;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return (args.First()!=null);\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                return [SBool trans:[args First]!=nil];\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        return args.First()!=None\r\n            \"\r\n        ]\r\n\t]\r\n\tif [\r\n\t\tcpp [\r\n            other \"\r\n            static Base * base_run(Node * args){\r\n                Bool * cond=static_cast<Bool*>(args->First());\r\n                Base * ret=NULL;\r\n                args=args->Rest();\r\n                if (cond==Bool::True) {\r\n                    ret=args->First();\r\n                }else{\r\n                    args=args->Rest();\r\n                    if(args!=NULL){\r\n                        ret=args->First();\r\n                    }\r\n                }\r\n                return ret;\r\n            }\r\n            \"\r\n\t\t\trun \"\r\n                return base_run(args);\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            other \"\r\n            public static Object base_run(Node<Object> args){\r\n                bool c=(bool)args.First();\r\n                args=args.Rest();\r\n                if(c){\r\n                    return args.First();\r\n                }else{\r\n                    args=args.Rest();\r\n                    if(args!=null)\r\n                    {\r\n                        return args.First();\r\n                    }else{\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n\r\n            \"\r\n            run \"\r\n                return base_run(args);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n            IfFun.base_run=function(args){\r\n                if(args.First()){\r\n                    return args.Rest().First();\r\n                }else{\r\n                    args=args.Rest().Rest();\r\n                    if(args){\r\n                        return args.First();\r\n                    }else{\r\n                        return null;\r\n                    }\r\n                }\r\n            };\r\n            \"\r\n            run \"\r\n                return IfFun.base_run(args);\r\n            \"\r\n        ]\r\n        OC [\r\n            other \"\r\n            + (NSObject*)base_run:(SNode*)args{\r\n                SBool* c=(SBool*)[args First];\r\n                args=[args Rest];\r\n                if([c Value]){\r\n                    return [args First];\r\n                }else{\r\n                    args=[args Rest];\r\n                    if(args!=nil){\r\n                        return [args First];\r\n                    }else{\r\n                        return nil;\r\n                    }\r\n                }\r\n            }\r\n            \"\r\n            run \"\r\n                return [S_IfFun base_run:args];\r\n            \"\r\n        ]\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(args):\r\n        if args.First():\r\n            return args.Rest().First()\r\n        else:\r\n            args=args.Rest().Rest()\r\n            if args!=None:\r\n                return args.First()\r\n            else:\r\n                return None\r\n            \"\r\n            run \"\r\n        return IfFun.base_run(args)\r\n            \"\r\n        ]\r\n\t]\r\n    `是否是同一个内存对象`\r\n    eq [\r\n        cpp [\r\n            run \"\r\n                Base * old=args->First();\r\n                bool eq=true;\r\n                Node * t=args->Rest();\r\n                while(eq && t!=NULL){\r\n                    eq=t->First()==old;\r\n                    old=t->First();\r\n                    t=t->Rest();\r\n                }\r\n                return Bool::trans(eq);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Object old=args.First();\r\n                bool eq=true;\r\n                Node<Object> t=args.Rest();\r\n                while(eq && t!=null){\r\n                    eq=t.First()==old;\r\n                    old=t.First();\r\n                    t=t.Rest();\r\n                }\r\n                return eq;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return eq(args,function(){return true;});\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                BOOL eq=YES;\r\n                NSObject* old=[args First];\r\n                SNode* t=[args Rest];\r\n                while(eq && t!=nil){\r\n                    eq=([t First]==old);\r\n                    old=[t First];\r\n                    t=[t Rest];\r\n                }\r\n                return [SBool trans:eq];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        eq=True \r\n        old=args.First()\r\n        t=args.Rest()\r\n        while(eq and t!=None):\r\n            eq=(t.First()==old)\r\n            old=t.First()\r\n            t=t.Rest()\r\n        return eq\r\n            \"\r\n        ]\r\n    ]\r\n    apply [\r\n        `\r\n            计划这样改造这个函数，只有两个参数时，按原计划。\r\n            N个参数时，后面的计算结果依次返回作前面的参数\r\n        `\r\n        cpp [\r\n            run \"\r\n                Function *f=static_cast<Function*>(args->First());\r\n                Node *f_args=static_cast<Node*>(args->Rest()->First());\r\n                Base* b=f->exec(f_args);\r\n                if(b!=NULL){\r\n                    b->eval_release();/*从函数出来都默认加了1，故需要eval_release再传递给下一个表达式*/\r\n                }\r\n                return b;\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Function f=args.First() as Function;\r\n                args=args.Rest();\r\n                return f.exec(args.First() as Node<Object>);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var run=args.First();\r\n                args=args.Rest();\r\n                return run.exec(args.First());\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                SFunction* f=(SFunction*)[args First];\r\n                SNode* n_args=(SNode*)[[args Rest] First];\r\n                NSObject* b=[f exec:n_args];\r\n                if(b!=nil){\r\n                    [SBase SEvalRelease:b];\r\n                }\r\n                return b;\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        f=args.First()\r\n        n_args=args.Rest().First()\r\n        return f.exe(n_args)\r\n            \"\r\n        ]\r\n    ]\r\n]",
  "lib-path/g_Lib/system/math.lisp": "[\r\n    + [\r\n        alias AddFun\r\n        cpp [\r\n            run \"\r\n                int all=0;\r\n                for(Node * t=args;t!=NULL;t=t->Rest()){\r\n                    Int * it=static_cast<Int*>(t->First());\r\n                    all=all+it->Value();\r\n                }\r\n                return new Int(all);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                int all=0;\r\n                for(Node<Object> t=args;t!=null;t=t.Rest())\r\n                {\r\n                    int it=(int)t.First();\r\n                    all=all+it;\r\n                }\r\n                return all;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return reduce(args,function(last,now){\r\n                    return last+now;\r\n                },0);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        all=0\r\n        t=args\r\n        while t!=None:\r\n            all=all+t.First()\r\n            t=t.Rest()\r\n        return all\r\n            \"\r\n        ]\r\n    ]\r\n    - [\r\n        alias SubFun\r\n        cpp [\r\n            run \"\r\n                int all=static_cast<Int*>(args->First())->Value();\r\n                args=args->Rest();\r\n                for(Node * t=args;t!=NULL;t=t->Rest()){\r\n                    Int * it=static_cast<Int*>(t->First());\r\n                    all=all-it->Value();\r\n                }\r\n                return new Int(all);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                int all=(int)args.First();\r\n                args=args.Rest();\r\n                for(Node<Object> t=args;t!=null;t=t.Rest())\r\n                {\r\n                    int it=(int)args.First();\r\n                    all=all-it;\r\n                }\r\n                return all;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var r=args.First();\r\n                return reduce(args.Rest(),function(last,now){\r\n                    return last-now;\r\n                },r);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        all=args.First()\r\n        args=args.Rest()\r\n        while args!=None:\r\n            all=all-args.First()\r\n            args=args.Rest()\r\n        return all\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    * [\r\n        alias MultiFun\r\n        cpp [\r\n            run \"\r\n                int all=1;\r\n                for(Node * t=args;t!=NULL;t=t->Rest()){\r\n                    Int * it=static_cast<Int*>(t->First());\r\n                    all=all*it->Value();\r\n                }\r\n                return new Int(all);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return reduce(args,function(last,now){\r\n                    return last*now;\r\n                },1);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        all=1\r\n        t=args\r\n        while t!=None:\r\n            all=all*t.First()\r\n            t=t.Rest()\r\n        return all\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    / [\r\n        alias DivFun\r\n        js [\r\n            run \"\r\n                var r=args.First();\r\n                return reduce(args.Rest(),function(last,now){\r\n                    return last/now;\r\n                },r);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        all=args.First()\r\n        args=args.Rest()\r\n        while args!=None:\r\n            all=all/args.First()\r\n            args=args.Rest()\r\n        return all\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    parseInt [\r\n        js [\r\n            run \"\r\n                return parseInt(args.First());\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    >  [\r\n        alias MBiggerFun\r\n        cpp [\r\n            run \"\r\n                bool ret=true;\r\n                Int* last=static_cast<Int*>(args->First());\r\n                args=args->Rest();\r\n                while(args!=NULL && ret){\r\n                    Int* current=static_cast<Int*>(args->First());\r\n                    ret=(last->Value()>current->Value());\r\n                    last=current;\r\n                    args=args->Rest();\r\n                }\r\n                return Bool::trans(ret);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                bool ret=true;\r\n                int last=(int)args.First();\r\n                args=args.Rest();\r\n                while(args!=null && ret)\r\n                {\r\n                    int current=(int)args.First();\r\n                    ret=(last>current);\r\n                    last=current;\r\n                    args=args.Rest();\r\n                }\r\n                return ret;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                //数字\r\n                return compare(args,check_is_number,function(last,now){\r\n                    return (last>now);\r\n                });\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        ret=True \r\n        last=args.First()\r\n        args=args.Rest()\r\n        while (args!=None and ret):\r\n            ret=last>args.First()\r\n            args=args.Rest()\r\n        return ret\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    < [\r\n        alias MSmallerFun\r\n        cpp [\r\n            run \"\r\n                bool ret=true;\r\n                Int* last=static_cast<Int*>(args->First());\r\n                args=args->Rest();\r\n                while(args!=NULL && ret){\r\n                    Int* current=static_cast<Int*>(args->First());\r\n                    ret=(last->Value()<current->Value());\r\n                    last=current;\r\n                    args=args->Rest();\r\n                }\r\n                return Bool::trans(ret);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                bool ret=true;\r\n                int last=(int)args.First();\r\n                args=args.Rest();\r\n                while(args!=null && ret)\r\n                {\r\n                    int current=(int)args.First();\r\n                    ret=(last<current);\r\n                    last=current;\r\n                    args=args.Rest();\r\n                }\r\n                return ret;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                //数字\r\n                return compare(args,check_is_number,function(last,now){\r\n                    return (last<now);\r\n                });\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        ret=True \r\n        last=args.First()\r\n        args=args.Rest()\r\n        while (args!=None and ret):\r\n            ret=last<args.First()\r\n            args=args.Rest()\r\n        return ret\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    = [\r\n        alias MEqFun\r\n        cpp [\r\n            other \"\r\n            static bool base_run(Node* args){\r\n                bool ret=true;\r\n                Int* last=static_cast<Int*>(args->First());\r\n                args=args->Rest();\r\n                while(args!=NULL && ret){\r\n                    Int* current=static_cast<Int*>(args->First());\r\n                    ret=(last->Value()==current->Value());\r\n                    last=current;\r\n                    args=args->Rest();\r\n                }\r\n                return ret;\r\n            }\r\n            \"\r\n            run \"\r\n                return Bool::trans(base_run(args));\r\n            \"\r\n        ]\r\n        C# [\r\n            other \"\r\n            public static bool base_run(Node<Object> args){\r\n                bool ret=true;\r\n                int last=(int)args.First();\r\n                args=args.Rest();\r\n                while(args!=null && ret)\r\n                {\r\n                    int current=(int)args.First();\r\n                    ret=(last==current);\r\n                    last=current;\r\n                    args=args.Rest();\r\n                }\r\n                return ret;\r\n            }\r\n            \"\r\n            run \"\r\n                return base_run(args);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n                MEqFun.base_run=function(args){\r\n                    return eq(args,check_is_number);\r\n                }\r\n            \"\r\n            run \"\r\n                return MEqFun.base_run(args);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(args):\r\n        ret=True \r\n        last=args.First()\r\n        args=args.Rest()\r\n        while (args!=None and ret):\r\n            ret=(last==args.First())\r\n            args=args.Rest()\r\n        return ret\r\n            \"\r\n            run \"\r\n        return MEqFun.base_run(args)\r\n            \"\r\n        ]\r\n    ]\r\n]",
  "lib-path/g_Lib/system/str.lisp": "[\r\n    str-eq [\r\n        cpp [\r\n            run \"\r\n                String *s1=static_cast<String*>(args->First());\r\n                args=args->Rest();\r\n                String *s2=static_cast<String*>(args->First());\r\n                return Bool::trans(s1->StdStr()==s2->StdStr());\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                String a=args.First() as String;\r\n                args=args.Rest();\r\n                String b=args.First() as String;\r\n                return a==b;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return eq(args,function(s){\r\n                    if(s && s.constructor==String){\r\n                        return true;\r\n                    }else{\r\n                        return false;\r\n                    }\r\n                });\r\n            \"\r\n        ]\r\n    ]\r\n    str-length [\r\n        cpp [\r\n            run \"\r\n                String *str=static_cast<String*>(args->First());\r\n                return new Int(str->StdStr().size());\r\n            \"\r\n        ] \r\n        C# [\r\n            run \"\r\n                String a=args.First() as String;\r\n                return a.Length;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                return str.length;\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return len(args.First())\r\n            \"\r\n        ]\r\n    ]\r\n    str-charAt [\r\n        cpp [\r\n            run \"\r\n                String *str=static_cast<String*>(args->First());\r\n                Int * i=static_cast<Int*>(args->Rest()->First());\r\n                char x[]={str->StdStr()[i->Value()],'\\\\0'};\r\n                return new String(x);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                String a=args.First() as String;\r\n                args=args.Rest();\r\n                int b=(int)args.First();\r\n                return \\\"\\\"+a[b];\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                args=args.Rest();\r\n                var index=args.First();  \r\n                return str[index];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First()[args.Rest().First()]\r\n            \"\r\n        ]\r\n    ]\r\n\r\n    str-substr [\r\n        `\r\n        参数1：字符串\r\n        参数2：开始位置\r\n        参数3：长度\r\n        `\r\n        cpp [\r\n            run \"\r\n                String * stre=static_cast<String*>(args->First());\r\n                args=args->Rest();\r\n                Int * begin=static_cast<Int*>(args->First());\r\n                args=args->Rest();\r\n                if(args==NULL){\r\n                    return new String(stre->StdStr().substr(begin->Value()));\r\n                }else{\r\n                    Int * len=static_cast<Int*>(args->First());\r\n                    return new String(stre->StdStr().substr(begin->Value(),len->Value()));\r\n                }\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                String a=args.First() as String;\r\n                args=args.Rest();\r\n                int begin=(int)args.First();\r\n                args=args.Rest();\r\n                if(args==null)\r\n                {\r\n                    return a.Substring(begin);\r\n                }else\r\n                {\r\n                    return a.Substring(begin,(int)args.First());\r\n                }\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var a=args.First();\r\n                args=args.Rest();\r\n                var begin=args.First();\r\n                args=args.Rest();\r\n                if(args==null){\r\n                    return a.substr(begin);\r\n                }else{\r\n                    return a.substr(begin,args.First());\r\n                }\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        a=args.First()\r\n        args=args.Rest()\r\n        begin=args.First()\r\n        args=args.Rest()\r\n        if args==None:\r\n            return a[begin:len(a)]\r\n        else:\r\n            return a[begin:(begin+args.First())]\r\n            \"\r\n        ]\r\n    ]\r\n    str-join [\r\n        cpp [\r\n            run \"\r\n                Node * vs=static_cast<Node*>(args->First());\r\n                args=args->Rest();\r\n                int split_size=0;\r\n                String *split=NULL;\r\n                if(args!=NULL)\r\n                {\r\n                    split=static_cast<String*>(args->First());\r\n                    split_size=split->StdStr().size();\r\n                }\r\n                int size=0;\r\n                for(Node *t=vs;t!=NULL;t=t->Rest())\r\n                {\r\n                    String * s=static_cast<String*>(t->First());\r\n                    size+=s->StdStr().size()+split_size;\r\n                }\r\n                size=size-split_size;\r\n                char *cs=new char[size+1];\r\n\r\n                int d=0;\r\n                for(Node *t=vs;t!=NULL;t=t->Rest())\r\n                {\r\n                    String * s=static_cast<String*>(t->First());\r\n                    for(unsigned i=0;i<s->StdStr().size();i++)\r\n                    {\r\n                        cs[d]=s->StdStr()[i];\r\n                        d++;\r\n                    }\r\n                    if(t->Rest()!=NULL && split_size!=0)\r\n                    {\r\n                        for(int i=0;i<split_size;i++){\r\n                            cs[d]=split->StdStr()[i];\r\n                            d++;\r\n                        }\r\n                    }\r\n                }\r\n                cs[size]='\\\\0';\r\n                string str(cs);\r\n                delete [] cs;\r\n                return new String(str);\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Node<Object> vs=args.First() as Node<Object>;\r\n                args=args.Rest();\r\n                String split=\\\"\\\";\r\n                if(args!=null)\r\n                {\r\n                    split=args.First() as String;\r\n                }\r\n                StringBuilder sb=new StringBuilder();\r\n                for(Node<Object> tmp=vs;tmp!=null;tmp=tmp.Rest())\r\n                {\r\n                    sb.Append(tmp.First() as String);\r\n                    if(tmp.Rest()!=null)\r\n                    {\r\n                        sb.Append(split);\r\n                    }\r\n                }\r\n                return sb.ToString();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                //字符串\r\n                var array=args.First();\r\n                var split=\\\"\\\";\r\n                if(args.Rest()!=null){\r\n                    split=args.Rest().First();\r\n                }\r\n                var r=\\\"\\\";\r\n                for(var t=array;t!=null;t=t.Rest()){\r\n                    r=r+t.First()+split;\r\n                }\r\n                return r.substr(0,r.length-split.length);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        array=args.First()\r\n        split=\\\"\\\";\r\n        args=args.Rest()\r\n        if args!=None:\r\n            split=args.First()\r\n        sb=[]\r\n        while array!=None:\r\n            sb.append(array.First())\r\n            array=array.Rest()\r\n        return split.join(sb)\r\n            \"\r\n        ]\r\n    ]\r\n    str-split [\r\n        C# [\r\n            run \"\r\n                String str = args.First() as String;\r\n                args = args.Rest();\r\n                String split = \\\"\\\";\r\n                if (args != null)\r\n                {\r\n                    split = args.First() as String;\r\n                }\r\n                Node<Object> r = null;\r\n                if (split == \\\"\\\")\r\n                {\r\n                    for (int i = str.Length-1; i>-1; i--)\r\n                    {\r\n                        r = Node<Object>.extend(str[i] + \\\"\\\", r);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    int last_i = 0;\r\n                    while (last_i >-1)\r\n                    {\r\n                        int new_i = str.IndexOf(split, last_i);\r\n                        if (new_i > -1)\r\n                        {\r\n                            r = Node<Object>.extend(str.Substring(last_i, new_i - last_i), r);\r\n                            last_i = new_i+split.Length;\r\n                        }\r\n                        else\r\n                        {\r\n                            //最后\r\n                            r = Node<Object>.extend(str.Substring(last_i), r);\r\n                            last_i = new_i;\r\n                        }\r\n                    }\r\n                    r = Node<Object>.reverse(r);\r\n                }\r\n                return r;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var a=args.First();\r\n                var split=\\\"\\\";\r\n                args=args.Rest()\r\n                if(args!=null){\r\n                    split=args.First();\r\n                }\r\n                return a.split(split);\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        a=args.First()\r\n        split=\\\"\\\"\r\n        args=args.Rest()\r\n        if args!=None:\r\n            split=args.First()\r\n        if split==\\\"\\\":\r\n            sb=[]\r\n            i=0\r\n            len_a=len(a)\r\n            while i<len_a:\r\n                sb.append(a[i])\r\n                i=i+1\r\n            return sb\r\n        else:\r\n            return a.split(split)\r\n            \"\r\n        ]\r\n    ]\r\n    str-upper[\r\n        C# [\r\n            run \"\r\n                return (args.First() as String).ToUpper();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return args.First().toUpperCase();\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First().upper()\r\n            \"\r\n        ]\r\n    ]\r\n    str-lower[\r\n        C# [\r\n            run \"\r\n                return (args.First() as String).ToLower();\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                return args.First().toLowerCase();\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First().lower()\r\n            \"\r\n        ]\r\n    ]\r\n    str-trim [\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                return str.trim();\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        return args.First().strip()\r\n            \"\r\n        ]\r\n    ]\r\n    str-indexOf [\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                args=args.Rest();\r\n                var v=args.First();\r\n                return str.indexOf(v);\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        stre=args.First()\r\n        args=args.Rest()\r\n        v=args.First()\r\n        return stre.find(v)\r\n            \"\r\n        ]\r\n    ]\r\n    str-lastIndexOf [\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                args=args.Rest();\r\n                var v=args.First();\r\n                return str.lastIndexOf(v);\r\n            \"\r\n        ]\r\n    ]\r\n    str-startsWith [\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                args=args.Rest();\r\n                var v=args.First();\r\n                return str.startsWith(v);\r\n            \"\r\n        ]\r\n    ]\r\n    str-endsWith [\r\n        js [\r\n            run \"\r\n                var str=args.First();\r\n                args=args.Rest();\r\n                var v=args.First();\r\n                return str.endsWith(v);\r\n            \"\r\n        ]\r\n    ]\r\n    str-reduce-left [\r\n        cpp [\r\n            run \"\r\n                String * stre=static_cast<String*>(args->First());\r\n                args=args->Rest();\r\n                Function * f=static_cast<Function*>(args->First());\r\n                args=args->Rest();\r\n                Base * init=args->First();\r\n                unsigned size=stre->StdStr().size();\r\n                for(unsigned i=0;i<size;i++){\r\n                    char c[]={stre->StdStr()[i],'\\\\0'};\r\n                    String *cs=new String(string(c));\r\n                    Int* is=new Int(i);\r\n                    Node *targs=new Node(init,new Node(cs,new Node(is,NULL)));\r\n                    targs->retain();\r\n                    Base *new_init=f->exec(targs);\r\n                    targs->release();\r\n                    if(new_init!=NULL){\r\n                        new_init->eval_release();\r\n                    }\r\n                    init=new_init;\r\n                }\r\n                return init;\r\n            \"\r\n        ]\r\n    ]\r\n    `参考str-reduce-left`\r\n    str-reduce-right [\r\n        cpp [\r\n            run \"\r\n                String * stre=static_cast<String*>(args->First());\r\n                args=args->Rest();\r\n                Function * f=static_cast<Function*>(args->First());\r\n                args=args->Rest();\r\n                Base * init=args->First();\r\n                unsigned size=stre->StdStr().size();\r\n                for(unsigned i=size-1;i!=0;i--){\r\n                    char c[]={stre->StdStr()[i],'\\\\0'};\r\n                    String *cs=new String(string(c));\r\n                    Int* is=new Int(i);\r\n                    Node *targs=new Node(init,new Node(cs,new Node(is,NULL)));\r\n                    targs->retain();\r\n                    Base *new_init=f->exec(targs);\r\n                    targs->release();\r\n                    if(new_init!=NULL){\r\n                        new_init->eval_release();\r\n                    }\r\n                    init=new_init;\r\n                }\r\n                return init;\r\n            \"\r\n        ]\r\n    ]\r\n]",
  "lib-path/g_Lib/system/toStr.lisp": "[\r\n\tlog [\r\n\t\tcpp [\r\n\t\t\trun \"\r\n                for (Node * tmp=args; tmp!=NULL; tmp=tmp->Rest()) {\r\n                    Base * v=tmp->First();\r\n                    cout<<system::toString(v,true)<<\\\" \\\";\r\n                }\r\n                cout<<endl;\r\n                return NULL;\r\n\t\t\t\"\r\n\t\t]\r\n        C# [\r\n            run \"\r\n                StringBuilder sb = new StringBuilder();\r\n                for(Node<Object> t=args;t!=null;t=t.Rest()){\r\n                    sb.Append(System.toString(t.First(),true)).Append(\\\" \\\");\r\n                }\r\n                Console.WriteLine(sb.ToString());\r\n                return null;\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                p.log(args);\r\n            \"\r\n        ]\r\n        OC [\r\n            run \"\r\n                NSMutableString* str=[NSMutableString new];\r\n                for (SNode* t=args; t!=nil; t=[t Rest]) {\r\n                    [str appendString:[SSystem toString:[t First] trans:YES]];\r\n                    [str appendString:@\\\" \\\"];\r\n                }\r\n                NSLog(@\\\"%@\\\",str);\r\n                [SBase SEvalRelease:str];\r\n                return nil;\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        sb=[]\r\n        tmp=args\r\n        while tmp!=None:\r\n            sb.append(System.toString(tmp.First(),True))\r\n            sb.append(\\\" \\\")\r\n            tmp=tmp.Rest()\r\n        print(\\\"\\\".join(sb))\r\n        return None\r\n            \"\r\n        ]\r\n\t]\r\n\ttoString [\r\n        `\r\n        String->不变\r\n        Int->String\r\n        Bool->String\r\n        List->[]\r\n        Function->{}\r\n        `\r\n        cpp [\r\n            run \"\r\n                Base* b=args->First();\r\n                return new String(system::toString(b,false));\r\n            \"\r\n        ]\r\n\r\n        C# [\r\n            run \"\r\n                Object b=args.First();\r\n                return System.toString(b,false);\r\n            \"\r\n        ]\r\n\r\n        js [\r\n            run \"\r\n                var b=args.First();\r\n                return p.toString(b,false);\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                NSObject* b=[args First];\r\n                return [SSystem toString:b trans:NO];\r\n            \"\r\n        ]\r\n\r\n        python [\r\n            run \"\r\n        b=args.First()\r\n        return System.toString(b,False)\r\n            \"\r\n        ]\r\n    ]\r\n    stringify [\r\n        `\r\n            和log不同，log如果是字符串，会加上引号log函数是多个，返回值显示是1个。\r\n            log函数对每一个转换，不是单纯的列表内\r\n            只是转换成字符串类型\r\n        `\r\n        cpp [\r\n            run \"\r\n                Base* b=args->First();\r\n                return new String(system::toString(b,true));\r\n            \"\r\n        ]\r\n        C# [\r\n            run \"\r\n                Object b=args.First();\r\n                return System.toString(b,true);\r\n            \"\r\n        ]\r\n        js [\r\n            run \"\r\n                var b=args.First();  \r\n                return p.toString(b,true);\r\n            \"\r\n        ]\r\n\r\n        OC [\r\n            run \"\r\n                NSObject* b=[args First];\r\n                return [SSystem toString:b trans:YES];\r\n            \"\r\n        ]\r\n        python [\r\n            run \"\r\n        b=args.First()\r\n        return System.toString(b,True)\r\n            \"\r\n        ]\r\n    ]\r\n]",
  "lib-path/g_Lib/system/type.lisp": "[\r\n    type [\r\n        cpp [\r\n            other \r\n            ({\r\n                (let (init def out release)\r\n                    (reduce \r\n                        [\r\n                            list\r\n                            string\r\n                            function\r\n                            int\r\n                            bool\r\n                            user\r\n                            token\r\n                            exp\r\n                            location\r\n                        ]\r\n                        {\r\n                            (let ((init def out release) v) args)\r\n                            (list\r\n                                (extend (str-join [\"s_\" 'v \"=new String(\\\"\" 'v \"\\\");\" \"s_\" 'v \"->retain();\"]) init)\r\n                                (extend (str-join [\"String* s_\" 'v \";\"]) def)\r\n                                (extend (str-join [\"String* S_\" 'v \"(){ return s_\" 'v \";}\"]) out)\r\n                                (extend (str-join [\"s_\" 'v \"->release();\"]) release)\r\n                            )\r\n                        }\r\n                        [[] [] [] []]\r\n                    )\r\n                )\r\n                (str-join\r\n                    [\r\n                        \"TypeFun(){\"\r\n                            (str-join init \"\\n\")\r\n                        \"}\"\r\n                        \"~TypeFun(){\"\r\n                            (str-join release \"\\n\")\r\n                        \"}\"\r\n                        (str-join out \"\\n\")\r\n                        \"\r\n                        String* base_run(Base* b){\r\n                            String* s;\r\n                            if(b==NULL){\r\n                                s=s_list;\r\n                            }else{\r\n                                Base::S_Type t=b->stype();\r\n                                if(t==Base::sList){\r\n                                    s=s_list;\r\n                                }else\r\n                                if(t==Base::sFunction){\r\n                                    s=s_function;\r\n                                }else\r\n                                if(t==Base::sInt){\r\n                                    s=s_int;\r\n                                }else\r\n                                if(t==Base::sString){\r\n                                    s=s_string;\r\n                                }else\r\n                                if(t==Base::sBool){\r\n                                    s=s_bool;\r\n                                }else\r\n                                if(t==Base::sUser){\r\n                                    s=s_user;\r\n                                }else\r\n                                {\r\n                                    if(t==Base::sToken){\r\n                                        s=s_token;\r\n                                    }else\r\n                                    if(t==Base::sExp){\r\n                                        s=s_exp;\r\n                                    }else\r\n                                    if(t==Base::sLocation){\r\n                                        s=s_location;\r\n                                    }\r\n                                }\r\n                            }\r\n                            return s;\r\n                        }\r\n                        private:\r\n                        \"\r\n                        (str-join def \"\\n\")\r\n                    ]\r\n                    \"\\n\"\r\n                )\r\n            })\r\n            run \"\r\n                Base *b=args->First();\r\n                return base_run(b);\r\n            \"\r\n        ]\r\n        C# [\r\n            other \"\r\n                public static String base_run(Object b){\r\n                    if(b==null){\r\n                        return \\\"list\\\";\r\n                    }else{\r\n                        if(b is Node<Object>)\r\n                        {\r\n                            return \\\"list\\\";\r\n                        }else if(b is Function)\r\n                        {\r\n                            return \\\"function\\\";\r\n                        }else if(b is int)\r\n                        {\r\n                            return \\\"int\\\";\r\n                        }else if(b is String)\r\n                        {\r\n                            return \\\"string\\\";\r\n                        }else if(b is bool)\r\n                        {\r\n                            return \\\"bool\\\";\r\n                        }else{\r\n                            if(b is Token)\r\n                            {\r\n                                return \\\"token\\\";\r\n                            }else if(b is Exp)\r\n                            {\r\n                                return \\\"exp\\\";\r\n                            }else if(b is Location)\r\n                            {\r\n                                return \\\"location\\\";\r\n                            }else{\r\n                                return \\\"user\\\";\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            \"\r\n            run \"\r\n                Object b=args.First();\r\n                return base_run(b);\r\n            \"\r\n        ]\r\n        js [\r\n            other \"\r\n                TypeFun.base_run=function(n){\r\n                    if(n==null){\r\n                        return \\\"list\\\";\r\n                    }else{\r\n                        if(p.isList(n)){\r\n                            return \\\"list\\\";\r\n                        }else\r\n                        if(p.isFun(n)){\r\n                            return \\\"function\\\";\r\n                        }else{\r\n                            var t=typeof(n);\r\n                            if(t==\\\"string\\\"){\r\n                                return \\\"string\\\";\r\n                            }else\r\n                            if(t==\\\"boolean\\\"){\r\n                                return \\\"bool\\\";\r\n                            }else\r\n                            if(t==\\\"number\\\"){\r\n                                if(n%1===0){\r\n                                    return \\\"int\\\";\r\n                                }else{\r\n                                    return \\\"float\\\";\r\n                                }\r\n                            }else{\r\n                                return t;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            \"\r\n            run \"\r\n                var n=args.First();\r\n                return TypeFun.base_run(n);\r\n            \"\r\n        ]\r\n        OC [\r\n            other \"\r\n            +(NSString*)base_run:(NSObject*)n{\r\n                if(n==nil){\r\n                    return @\\\"list\\\";\r\n                }else{\r\n                    if([n isKindOfClass:[SNode class]]){\r\n                        return @\\\"list\\\";\r\n                    }else\r\n                    if([n isKindOfClass:[SFunction class]]){\r\n                        return @\\\"function\\\";\r\n                    }else\r\n                    if([n isKindOfClass:[SBool class]]){\r\n                        return @\\\"bool\\\";\r\n                    }else\r\n                    if([n isKindOfClass:[NSString class]]){\r\n                        return @\\\"string\\\";\r\n                    }else\r\n                    if([n isKindOfClass:[NSNumber class]]){\r\n                        return @\\\"int\\\";\r\n                    }else{\r\n                        return @\\\"\\\";\r\n                    }\r\n                }\r\n            }\r\n            \"\r\n            run \"\r\n                return [S_TypeFun base_run:[args First]];\r\n            \"\r\n        ]\r\n        python [\r\n            other \"\r\n    @staticmethod\r\n    def base_run(o):\r\n        if (o==None or isinstance(o,Node)):\r\n            return \\\"list\\\"\r\n        elif isinstance(o,Function):\r\n            return \\\"function\\\"\r\n        elif isinstance(o,bool):\r\n            return \\\"bool\\\"\r\n        elif isinstance(o,basestring):\r\n            return \\\"string\\\"\r\n        elif isinstance(o,int):\r\n            return \\\"int\\\"\r\n        else:\r\n            return \\\"\\\"\r\n            \"\r\n            run \"\r\n            return TypeFun.base_run(args.First())\r\n            \"\r\n        ]\r\n    ]\r\n]",
  "lib-path/g_Lib/trans_name.lisp": "`\r\n    将名字转成符合语法的\r\n`\r\n{\r\n    (let (k) args)\r\n    (let b \r\n        (if\r\n            (str-eq \r\n                (str-charAt k \r\n                    (- (str-length k) 1)\r\n                )\r\n                '?\r\n            )\r\n            'Is\r\n            \"\"\r\n        )\r\n    )\r\n    (let vs (str-split k \"\"))\r\n    (let \r\n        is?end (str-eq b \"\")\r\n        b  (if is?end (str-upper (first vs)) b)\r\n        vs  (if is?end (rest vs) vs)\r\n    )\r\n    (let vs \r\n        (reduce-right vs {\r\n            (let (init v i) args)\r\n            (let v \r\n                (if \r\n                    (str-eq v '-) \r\n                    '_ \r\n                    (if \r\n                        (str-eq v '?) \"\" v\r\n                    )\r\n                )\r\n            )\r\n            (extend v init)\r\n        }[Fun])\r\n    )\r\n    (str-join (extend b vs))\r\n}",
  "lib-path/index.lisp": "\r\n\r\n\r\n`致力于变成多平台通用的文件`\r\n(let \r\n\t`叠加两个，可以用reduce来做N次重复`\r\n\tcombine-two {\r\n\t\t(let (adds olds) args combine-two this)\r\n\t\t(if-run (exist? adds)\r\n\t\t\t{\r\n\t\t\t\t(let (x ...xs) adds)\r\n\t\t\t\t(if-run (exist? xs)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(extend x (combine-two xs olds))\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(extend x olds)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\tolds\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\t\r\n\treverse-join {\r\n\t\t(reduce args\r\n\t\t\t{\r\n\t\t\t\t(let (init xs) args)\r\n\t\t\t\t(reduce xs\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (init x) args)\r\n\t\t\t\t\t\t(extend x init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinit\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t[]\r\n\t\t)\r\n\t}\r\n)\r\n\r\n[\r\n\t!= '!=\r\n\tempty-fun 'empty-fun\r\n\ttype? {\r\n\t\t(let (x n) args)\r\n\t\t(str-eq (type x) n)\r\n\t}\r\n\t`如果没有，设置默认值`\r\n\tdefault 'default\r\n\t`从某处开始切片`\r\n\t`暂不添加slice，因为不知道是(slice from to) 还是 (slice from length)`\r\n\r\n\treduce 'reduce\r\n\t`reduce-left就是reduce`\r\n\treduce-left 'reduce\r\n\treduce-right 'reduce-right\r\n\r\n\t\r\n\t`异步的reduce`\r\n\tasync-reduce {\r\n\t\t(let (notice xs run init) args async-reduce this)\r\n\t\t(if-run (exist? xs)\r\n\t\t\t{\r\n\t\t\t\t(let (x ...xs) xs)\r\n\t\t\t\t(run \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t`单个的notice`\r\n\t\t\t\t\t\t(let (init) args)\r\n\t\t\t\t\t\t(async-reduce notice xs run init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinit x\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(notice init)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\r\n\t`与列表的reduce对应`\r\n\tkvs-reduce 'kvs-reduce\r\n\tkvs-reduce-left 'kvs-reduce\r\n\tkvs-reduce-right 'kvs-reduce-right\r\n\r\n\tasync-kvs-reduce {\r\n\t\t(let (notice kvs run init) args async-kvs-reduce this)\r\n\t\t(if-run (exist? kvs)\r\n\t\t\t{\r\n\t\t\t\t(let (k v ...kvs) kvs)\r\n\t\t\t\t(run \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t`单个的notice`\r\n\t\t\t\t\t\t(let (init) args)\r\n\t\t\t\t\t\t(async-kvs-reduce notice kvs run init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinit v k\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(notice init)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\r\n\t`\r\n\t类似js中的some，已经包含，\r\n\t这会对所有检查，即使已经存在了\r\n\t收集所有符合条件的，是filter\r\n\t统计符合条件的个数？\r\n\t检查存在的some\r\n\t`\r\n\tsome {\r\n\t\t(let (xs run) args)\r\n\t\t(reduce xs {\r\n\t\t\t(let (init x) args)\r\n\t\t\t(or init (run x))\r\n\t\t} false)\r\n\t}\r\n\r\n\tforEach {\r\n\t\t(let (xs run) args)\r\n\t\t(reduce-right xs {\r\n\t\t\t(let (init x) args)\r\n\t\t\t(run x)\r\n\t\t} [])\r\n\t}\r\n\r\n\tmap {\r\n\t\t(let (xs run) args)\r\n\t\t(reduce-right xs {\r\n\t\t\t(let (init x) args)\r\n\t\t\t(extend (run x ) init)\r\n\t\t} [])\r\n\t}\r\n\r\n\tfilter {\r\n\t\t(let (xs run) args)\r\n\t\t(reduce-right xs {\r\n\t\t\t(let (init x) args)\r\n\t\t\t(let is (run x))\r\n\t\t\t(if-run is\r\n\t\t\t\t{(extend x init)}\r\n\t\t\t\t{init}\r\n\t\t\t)\r\n\t\t} [])\r\n\t}\r\n\r\n\tcombine-two 'combine-two\r\n\r\n\t`类似js-Array的splice:list,slice-from,count,...adds，先不考虑异常`\r\n\tsplice  {\r\n\t\t(let (xs i count ...adds) args)\r\n\t\t(let olds  (slice-from xs (+ i count)))\r\n\t\t(let olds (combine-two adds olds))\r\n\t\t(combine-two (slice-to xs i) olds)\r\n\t}\r\n\t\r\n\t`其实是与splice-last对应`\r\n\tsplice-first {\r\n\t\t(let (xs count ...adds) args)\r\n\t\t(let olds (slice-from xs count))\r\n\t\t(combine-two adds olds)\r\n\t}\r\n\t`最后一个list,count,adds`\r\n\tsplice-last {\r\n\t\t(let (xs count ...adds) args)\r\n\t\t(let slice-from (- (length xs) count))\r\n\t\t(combine-two (slice-to xs slice-from) adds)\r\n\t}\r\n\r\n\tsort {\r\n\t\t`run flag v =0 <0 >0`\r\n\t\t(let (xs run) args sort this)\r\n\t\t(if-run (exist? xs)\r\n\t\t\t{\r\n\t\t\t\t(let (x ...xs) xs)\r\n\t\t\t\t(if-run (empty? xs)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t`只有一个元素`\r\n\t\t\t\t\t\t(list x)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t`有别的元素`\r\n\t\t\t\t\t\t(let (smallers eqs largers ) \r\n\t\t\t\t\t\t\t\t(reduce xs\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let ((smallers eqs largers) v) args)\r\n\t\t\t\t\t\t\t\t\t\t(let c (run x v))\r\n\t\t\t\t\t\t\t\t\t\t(if-run (= 0 c)\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t(list\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tsmallers\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(extend v eqs)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlargers\r\n\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t(if-run (> 0 c)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(list\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmallers\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\teqs\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(extend v largers)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`<`\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(list\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(extend v smallers)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\teqs\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlargers\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t(list [] [] [])\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t(reverse \r\n\t\t\t\t\t\t\t(reverse-join \r\n\t\t\t\t\t\t\t\t(sort smallers run)\r\n\t\t\t\t\t\t\t\t(extend x eqs) \r\n\t\t\t\t\t\t\t\t(sort largers run)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\r\n\tkvs-forEach {\r\n\t\t(let (kvs run) args)\r\n\t\t(kvs-reduce-right kvs {\r\n\t\t\t(let (init v k) args)\r\n\t\t\t(run v k)\r\n\t\t} [])\r\n\t}\r\n\r\n\tkvs-map {\r\n\t\t(let (kvs run) args)\r\n\t\t(kvs-reduce-right kvs \r\n\t\t\t{\r\n\t\t\t\t(let (init v k) args)\r\n\t\t\t\t(kvs-extend k (run v k) init)\r\n\t\t\t} \r\n\t\t\t[]\r\n\t\t)\r\n\t}\r\n\t`接受一组函数，如果一为假，不执行后续返回假；如果全为真，最后返回真`\r\n\tand_q {\r\n\t\t(let xs args and_q this)\r\n\t\t(if-run (exist? xs)\r\n\t\t\t{\r\n\t\t\t\t(let (x ...xs) xs)\r\n\t\t\t\t(if-run (x)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(apply and_q xs)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{false}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{true}\r\n\t\t)\r\n\t}\r\n\t`接受一组函数，有一个为真，不执行后续返回真；如果全为假，返回假`\r\n\tor_q {\r\n\t\t(let xs args or_q this)\r\n\t\t(if-run (exist? xs)\r\n\t\t\t{\r\n\t\t\t\t(let (x ...xs) xs)\r\n\t\t\t\t(if-run (x)\r\n\t\t\t\t\t{true}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(apply or_q xs)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{false}\r\n\t\t)\r\n\t}\r\n\t`条件执行`\r\n\tif-run 'if-run\r\n\tswitch {\r\n\t\t(let (str kvs default-fun) args)\r\n\t\t(let o (kvs-find1st kvs str))\r\n\t\t(if (exist? o) o (default default-fun empty-fun))\r\n\t}\r\n\t`多条件if,switch`\r\n\tswitch-run {\r\n\t\t(let run (apply switch args))\r\n\t\t(run)\r\n\t}\r\n]",
  "lib-path/mve/build-children.lisp": "\r\n\r\n{\r\n\t`从util里调入`\r\n\t(let \r\n\t\t`\r\n\t\tValue \r\n\t\tWatcher \r\n\t\tkey:children路径\r\n\t\tappendChild \r\n\t\tinsertChildBefore(pel,new_el,old_el)\r\n\t\tremoveChild\r\n\t\tbefore 可选\r\n\t\tafter 可选\r\n\t\t`\r\n\t\t(p) args\r\n\t\tchildOperate (load './childOperate.lisp)\r\n\t\tbuildArray (load './buildArray.lisp)\r\n\t\tbuildModel (load './buildModel.lisp)\r\n\t\ttype-key (str-join ['p.key - type])\r\n\t\tp-before (default p.before empty-fun)\r\n\t\tp-after (default p.after empty-fun)\r\n\t\tgetOArray {\r\n\t\t\t(let (row i) args)\r\n\t\t\t[\r\n\t\t\t\tdata (p.Value row)\r\n\t\t\t\tindex 'i\r\n\t\t\t]\r\n\t\t}\r\n\t\tupdateArrayData {\r\n\t\t\t(let (view data) args)\r\n\t\t\t(view.row.data data)\r\n\t\t}\r\n\t\tgetOModel {\r\n\t\t\t(let (row i) args)\r\n\t\t\t[\r\n\t\t\t\tdata 'row\r\n\t\t\t\tindex (p.Value i)\r\n\t\t\t]\r\n\t\t}\r\n\t\tupdateModelIndex {\r\n\t\t\t(let (view index) args)\r\n\t\t\t(view.row.index index)\r\n\t\t}\r\n\t)\r\n\t{\r\n\t\t(let \r\n\t\t\t(e x o) args\r\n\t\t\tchildren (kvs-find1st o.json p.key)\r\n\t\t)\r\n\t\t(if-run (str-eq 'kvs (kvs-find1st o.json type-key))\r\n\t\t\t{\r\n\t\t\t\t(if-run (exist? children.array)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let\r\n\t\t\t\t\t\t\t`是否初始化`\r\n\t\t\t\t\t\t\tisInit (cache false)\r\n\t\t\t\t\t\t\t`未初始化时缓存值`\r\n\t\t\t\t\t\t\tc-inits (cache [])\r\n\t\t\t\t\t\t\t(bc-after bc-destroy) \r\n\t\t\t\t\t\t\t\t(buildArray \r\n\t\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\t\tbuild (childOperate.build e children.repeat x.mve getOArray)\r\n\t\t\t\t\t\t\t\t\t\tno_cache 'p.no_cache\r\n\t\t\t\t\t\t\t\t\t\tafter {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(let init (childOperate.getInit view))\r\n\t\t\t\t\t\t\t\t\t\t\t(if-run (isInit)\r\n\t\t\t\t\t\t\t\t\t\t\t\t{(init)}\r\n\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(c-inits (extend init (c-inits)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tupdate-data 'updateArrayData\r\n\t\t\t\t\t\t\t\t\t\tdestroy 'childOperate.destroy\r\n\t\t\t\t\t\t\t\t\t\tappendChild {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.appendChild e.pel (view.obj.getElement))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tremoveChild {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.removeChild e.pel (view.obj.getElement))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t`Array的计算观察`\r\n\t\t\t\t\t\t\twatch \r\n\t\t\t\t\t\t\t\t(p.Watcher\r\n\t\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\t\tbefore {\r\n\t\t\t\t\t\t\t\t\t\t\t(p-before e.pel)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\texp {\r\n\t\t\t\t\t\t\t\t\t\t\t(children.array)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tafter {\r\n\t\t\t\t\t\t\t\t\t\t\t(bc-after (first args))\r\n\t\t\t\t\t\t\t\t\t\t\t(p-after e.pel)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\tk 'o.k \r\n\t\t\t\t\t\t\tinits (extend \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(forEach (c-inits) call)\r\n\t\t\t\t\t\t\t\t\t(c-inits [])\r\n\t\t\t\t\t\t\t\t\t(isInit true)\r\n\t\t\t\t\t\t\t\t} \r\n\t\t\t\t\t\t\t\to.inits\r\n\t\t\t\t\t\t\t) \r\n\t\t\t\t\t\t\tdestroys (extend \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(watch.disable)\r\n\t\t\t\t\t\t\t\t\t(bc-destroy)\r\n\t\t\t\t\t\t\t\t} \r\n\t\t\t\t\t\t\t\to.destroys\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(if-run (exist? children.model)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t(let bm \r\n\t\t\t\t\t\t\t\t\t(buildModel [\r\n\t\t\t\t\t\t\t\t\t\tbuild (childOperate.build e children.repeat x.mve getOModel)\r\n\t\t\t\t\t\t\t\t\t\tmodel 'children.model\r\n\t\t\t\t\t\t\t\t\t\tupdate-index 'updateModelIndex\r\n\t\t\t\t\t\t\t\t\t\tinit 'childOperate.init\r\n\t\t\t\t\t\t\t\t\t\tdestroy 'childOperate.destroy\r\n\t\t\t\t\t\t\t\t\t\tinsertChildBefore {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (new_view old_view) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.insertChildBefore e.pel (new_view.obj.getElement) (old_view.obj.getElement))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tremoveChild {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.removeChild e.pel (view.obj.getElement))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tappendChild {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.appendChild e.pel (view.obj.getElement))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t])\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\tk 'o.k\r\n\t\t\t\t\t\t\t\t\tinits (extend bm.init o.inits)\r\n\t\t\t\t\t\t\t\t\tdestroys (extend bm.destroy o.destroys)\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t(log \"error,需要array或model\")\r\n\t\t\t\t\t\t\t\to\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(reduce children\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t(init child) args\r\n\t\t\t\t\t\t\tobj (x.Parse x [\r\n\t\t\t\t\t\t\t\tjson 'child\r\n\t\t\t\t\t\t\t\te 'e\r\n\t\t\t\t\t\t\t\tk 'init.k\r\n\t\t\t\t\t\t\t\tinits 'init.inits\r\n\t\t\t\t\t\t\t\tdestroys 'init.destroys\r\n\t\t\t\t\t\t\t])\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t(p.appendChild e.pel obj.element)\r\n\t\t\t\t\t\tobj\r\n\t\t\t\t\t}\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\tk 'o.k \r\n\t\t\t\t\t\tinits 'o.inits \r\n\t\t\t\t\t\tdestroys o.destroys\r\n\t\t\t\t\t]\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}",
  "lib-path/mve/buildArray.lisp": "\r\n{\r\n\t`与js的array不同，使用倒置的顺序`\r\n\t`build after update-data destroy appendChild removeChild`\r\n\t(let (p) args)\r\n\t(let \r\n\t\tcaches (cache [])\r\n\t\tviews (cache [])\r\n\t\tupdate-views {\r\n\t\t\t(let (array) args)\r\n\t\t\t(\r\n\t\t\t\t{\r\n\t\t\t\t\t(let (vs as) args circle this)\r\n\t\t\t\t\t(if-run (exist? vs)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v ...vs) vs (a ...as) as)\r\n\t\t\t\t\t\t\t(p.update-data v a)\r\n\t\t\t\t\t\t\t(circle vs as)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t} \r\n\t\t\t\t(views) array\r\n\t\t\t)\r\n\t\t}\r\n\t\tlen-c {\r\n\t\t\t(len \r\n\t\t\t\t((first args))\r\n\t\t\t)\r\n\t\t}\r\n\t)\r\n\t[\r\n\t\t`after` \r\n\t\t{\r\n\t\t\t(let (array) args)\r\n\t\t\t(if-run \r\n\t\t\t\t(< (len array)(len-c views) )\r\n\t\t\t\t{\r\n\t\t\t\t\t`多出的`\r\n\t\t\t\t\t(let more (slice-from (views) (len array)))\r\n\t\t\t\t\t`移除视图上的元素`\r\n\t\t\t\t\t(forEach more p.removeChild)\r\n\t\t\t\t\t`更新视图上数据`\r\n\t\t\t\t\t(views (slice-to (views) (len array)))\r\n\t\t\t\t\t(update-views array)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t(if-run \r\n\t\t\t\t\t\t(< (len array) (len-c caches))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`向caches上增加`\r\n\t\t\t\t\t\t\t(let new-view (slice-to (caches) (len array)))\r\n\t\t\t\t\t\t\t(let more (slice-from new-view (len-c views)))\r\n\t\t\t\t\t\t\t(forEach more p.appendChild)\r\n\t\t\t\t\t\t\t(views new-view)\r\n\t\t\t\t\t\t\t(update-views array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`从caches向视图上增加`\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\tviews-len (len-c views)\r\n\t\t\t\t\t\t\t\tmore (slice-from (caches) views-len)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(forEach more p.appendChild)\r\n\t\t\t\t\t\t\t(views (caches))\r\n\t\t\t\t\t\t\t(update-views array)\r\n\t\t\t\t\t\t\t`新增加`\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\tc-l  (len-c caches)\r\n\t\t\t\t\t\t\t\tmore (slice-from array c-l)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(let (more-k) (reduce more\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t\t\t\t((init i) a) args\r\n\t\t\t\t\t\t\t\t\t\t\tv (p.build a i)\r\n\t\t\t\t\t\t\t\t\t\t\ti (+ i c-l 1)\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t(p.appendChild v)\r\n\t\t\t\t\t\t\t\t\t\t(p.after v)\r\n\t\t\t\t\t\t\t\t\t\t`因为把新增加的追加到后面了`\r\n\t\t\t\t\t\t\t\t\t\t(list \r\n\t\t\t\t\t\t\t\t\t\t\t(extend v init)\r\n\t\t\t\t\t\t\t\t\t\t\ti\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t[[] 'views-len]\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(caches (combine-two (caches) (reverse more-k)))\r\n\t\t\t\t\t\t\t(views (caches))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t\t`destroy`\r\n\t\t{\r\n\t\t\t(forEach (caches) p.destroy)\r\n\t\t}\r\n\t]\r\n}",
  "lib-path/mve/buildModel.lisp": "\r\n(let update {\r\n\t(let (update-index views index) args)\r\n\t(reduce views {\r\n\t\t(let (init view) args)\r\n\t\t(update-index view init)\r\n\t\t(+ init 1)\r\n\t} index)\r\n})\r\n{\r\n\t(let \r\n\t\t(p) args\r\n\t\tviews (cache [])\r\n\t\tview [\r\n\t\t\tinsert {\r\n\t\t\t\t(let \r\n\t\t\t\t\t(index row) args\r\n\t\t\t\t\tview (p.build row index)\r\n\t\t\t\t\tleft (slice-to (views) index)\r\n\t\t\t\t\tright (slice-from (views) index)\r\n\t\t\t\t)\r\n\t\t\t\t(if-run (exist? right)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(update p.update-index right (+ (len left) 1))\r\n\t\t\t\t\t\t(p.insertChildBefore view (first right))\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(p.appendChild view)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t\t(views (combine-two left (extend view right)))\r\n\t\t\t\t(p.init view)\r\n\t\t\t}\r\n\t\t\tremove {\r\n\t\t\t\t(let \r\n\t\t\t\t\t(index row) args\r\n\t\t\t\t\tview (p.build row index)\r\n\t\t\t\t\tleft (slice-to (views) index)\r\n\t\t\t\t\t(view ...right) (slice-from (views) index)\r\n\t\t\t\t)\r\n\t\t\t\t(update p.update-index right (len left))\r\n\t\t\t\t(views (combine-two left right))\r\n\t\t\t\t(p.destroy view)\r\n\t\t\t\t(p.removeChild view)\r\n\t\t\t}\r\n\t\t]\r\n\t)\r\n\t(p.model.addView view)\r\n\t(let (i initViews)\r\n\t\t(reduce (p.model.list)\r\n\t\t\t{\r\n\t\t\t\t(let \r\n\t\t\t\t\t((i xv) row) args\r\n\t\t\t\t\tview (p.build row i)\r\n\t\t\t\t)\r\n\t\t\t\t(p.appendChild view)\r\n\t\t\t\t(list \r\n\t\t\t\t\t(+ i 1)\r\n\t\t\t\t\t(extend view xv)\r\n\t\t\t\t)\r\n\t\t\t} [0 xv]\r\n\t\t)\r\n\t)\r\n\t(views (reverse initViews))\r\n\t[\r\n\t\tinit {\r\n\t\t\t(forEach initViews p.init)\r\n\t\t}\r\n\t\tdestroy {\r\n\t\t\t(forEach (views) p.destroy)\r\n\t\t\t(p.model.removeView view)\r\n\t\t}\r\n\t]\r\n}",
  "lib-path/mve/childOperate.lisp": "[\r\n    build {\r\n\t\t`下面调入`\r\n\t\t(let (e repeat mve getO) args)\r\n\t\t{\r\n\t\t\t`最终调入`\r\n\t\t\t(let \r\n\t\t\t\to (apply getO args)\r\n\t\t\t\tfn (mve { \r\n\t\t\t\t\t\t\t[element {\r\n\t\t\t\t\t\t\t\t\t(apply repeat o)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t[ \r\n\t\t\t\trow 'o\r\n\t\t\t\tobj (fn e)\r\n\t\t\t]\r\n\t\t}\r\n\t}\r\n\tgetInit {\r\n\t\t(let (view) args)\r\n\t\tview.obj.init\r\n\t}\r\n\tinit {\r\n\t\t(let (view) args)\r\n\t\t(view.obj.init)\r\n\t}\r\n\tdestroy {\r\n\t\t(let (view) args)\r\n\t\t(view.obj.destroy)\r\n\t}\r\n]",
  "lib-path/mve/DOM/DOM.lisp": "[\r\n\tcreateElement {\r\n\t\t(let (type NS) args)\r\n\t\t(if-run (exist? NS)\r\n\t\t\t{\r\n\t\t\t\t(js-call 'document 'createElement (list NS type))\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(js-call 'document 'createElement (list type))\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tcreateTextNode {\r\n\t\t(js-call 'document 'createTextNode args)\r\n\t}\r\n\tappendChild {\r\n\t\t(let (el child) args)\r\n\t\t(js-call el 'appendChild (list child))\r\n\t}\r\n\treplaceWith {\r\n\t\t(let (old-e new-e) args)\r\n\t\t(let pn (js-attr old-e 'parentNode))\r\n\t\t(js-call pn 'replaceChild (list new-e old-e))\r\n\t}\r\n\tremoveChild {\r\n\t\t(let (el child) args)\r\n\t\t(js-call el 'removeChild (list child))\r\n\t}\r\n\tattr {\r\n\t\t(let (el key value) args)\r\n\t\t(if-run (= (length args) 3)\r\n\t\t\t{\r\n\t\t\t\t`设值`\r\n\t\t\t\t(if-run (exist? value)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(js-call el 'removeAttribute (list key))\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(js-call el 'setAttribute (list key value))\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t`取值`\r\n\t\t\t\t(js-call el 'getAttribute)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tstyle {\r\n\t\t(let \r\n\t\t\t(el key value) args\r\n\t\t\tstyle (js-attr el 'style)\r\n\t\t)\r\n\t\t(if-run (= (length args) 3)\r\n\t\t\t{\r\n\t\t\t\t`设值`\r\n\t\t\t\t(js-attr style key value)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t`取值`\r\n\t\t\t\t(js-attr style key)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tprop {\r\n\t\t(let (el key value) args)\r\n\t\t(if-run (= (length args) 3)\r\n\t\t\t{\r\n\t\t\t\t`设值`\r\n\t\t\t\t(js-attr el key value)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t`取值`\r\n\t\t\t\t(js-attr el key)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tevent {\r\n\t\t(let (el key value) args)\r\n\t\t(js-call 'mb.DOM 'addEvent (list el key value))\r\n\t}\r\n\ttext {\r\n\t\t(let (el value) args)\r\n\t\t(if-run (= (length args) 2)\r\n\t\t\t{\r\n\t\t\t\t`设值`\r\n\t\t\t\t(js-attr el 'innerText value)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t`取值`\r\n\t\t\t\t(js-attr el 'innerText)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tvalue {\r\n\t\t(let (el value) args)\r\n\t\t(if-run (= (length args) 2)\r\n\t\t\t{\r\n\t\t\t\t`设值`\r\n\t\t\t\t(js-attr el 'value value)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t`取值`\r\n\t\t\t\t(js-attr el 'value)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\thtml {\r\n\t\t(let (el value) args)\r\n\t\t(if-run (= (length args) 2)\r\n\t\t\t{\r\n\t\t\t\t`设值`\r\n\t\t\t\t(js-attr el 'innerHTML value)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t`取值`\r\n\t\t\t\t(js-attr el 'innerHTML)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\r\n\talert {\r\n\t\t(js-call 'window 'alert args)\r\n\t}\r\n\r\n\tconfirm {\r\n\t\t(js-call 'window 'confirm args)\r\n\t}\r\n]",
  "lib-path/mve/DOM/index.lisp": "{\r\n\t(let \r\n\t\tDOM (load './DOM.lisp)\r\n\t\tutil  (load '../util.lisp)\r\n\t\texp (load '../exp.lisp)\r\n\t\tParse (load '../parse.lisp)\r\n\t\tbuild-children (\r\n\t\t\t(load '../build-children.lisp)\r\n\t\t\t[\r\n\t\t\t\tValue 'util.Value\r\n\t\t\t\tWatcher 'util.Watcher\r\n\t\t\t\tkey children\r\n\t\t\t\tappendChild 'DOM.appendChild\r\n\t\t\t\tremoveChild 'DOM.removeChild\r\n\t\t\t]\r\n\t\t)\r\n\t\tlocsize [\r\n\t\t\twidth height left top right bottom\r\n\t\t]\r\n\t\tbindKV {\r\n\t\t\t(let (bind key value f) args)\r\n\t\t\t(bind value {\r\n\t\t\t\t\t(f key \r\n\t\t\t\t\t\t(first args)\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t} \r\n\t\tbindMap {\r\n\t\t\t(let (bind map f) args)\r\n\t\t\t(if-run (exist? map)\r\n\t\t\t\t{\r\n\t\t\t\t\t(kvs-forEach map \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v k) args)\r\n\t\t\t\t\t\t\t(bindKV bind k v f)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t} \r\n\t\tbindEvent {\r\n\t\t\t(let (map f) args)\r\n\t\t\t(if-run (exist? map)\r\n\t\t\t\t{\r\n\t\t\t\t\t(kvs-forEach map \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v k) args)\r\n\t\t\t\t\t\t\t(f k v)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t} \r\n\t\treplaceChild {\r\n\t\t\t(let (pel old_el new_el) args)\r\n\t\t\t(DOM.replaceWith old_el new_el)\r\n\t\t}\r\n\t)\r\n\t(exp\r\n\t\tlocsize\r\n\t\tDOM\r\n\t\t(Parse \r\n\t\t\tlocsize\r\n\t\t\t[\r\n\t\t\t\tlocsize {\r\n\t\t\t\t\t(let (el key value) args)\r\n\t\t\t\t\t(DOM.style el key \r\n\t\t\t\t\t\t(if value \r\n\t\t\t\t\t\t\t(str-join ['value px])\r\n\t\t\t\t\t\t\t\"\"\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\tcreateTextNode {\r\n\t\t\t\t\t(let (x o) args)\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\telement (DOM.createTextNode (default o.json \"\"))\r\n\t\t\t\t\t\tk 'o.k\r\n\t\t\t\t\t\tinits 'o.inits\r\n\t\t\t\t\t\tdestroys 'o.destroys\r\n\t\t\t\t\t]\r\n\t\t\t\t}\r\n\t\t\t\tbuildElement {\r\n\t\t\t\t\t(let (x o) args)\r\n\t\t\t\t\t`原生组件`\r\n\t\t\t\t\t(let e  (DOM.createElement o.json.type o.json.NS))\r\n\t\t\t\t\t`children`\r\n\t\t\t\t\t(let obj (build-children \r\n\t\t\t\t\t\t[pel 'e replaceChild 'replaceChild] x o)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\telement 'e\r\n\t\t\t\t\t\tk 'obj.k\r\n\t\t\t\t\t\tinits 'obj.inits\r\n\t\t\t\t\t\tdestroys 'obj.destroys\r\n\t\t\t\t\t]\r\n\t\t\t\t}\r\n\t\t\t\tmakeUpElement {\r\n\t\t\t\t\t(let (e x json) args)\r\n\t\t\t\t\t`attr属性`\r\n\t\t\t\t\t(bindMap x.bind json.attr \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.attr (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`style属性`\r\n\t\t\t\t\t(bindMap x.bind json.style\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.style (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`动作`\r\n\t\t\t\t\t(bindEvent json.event\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.event (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`内部字符`\r\n\t\t\t\t\t(x.if-bind json.text \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.text (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`内部值`\r\n\t\t\t\t\t(x.if-bind json.value\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.value (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`innerHTML`\r\n\t\t\t\t\t(x.if-bind json.html\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.html (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t)\r\n\t)\r\n}",
  "lib-path/mve/exp.lisp": "{\r\n\t(let \r\n\t\tutil (load './util.lisp)\r\n\t\t(locsize DOM Parse) args\r\n\t\t`供后面inits和destroys使用`\r\n\t\tforEach-run {\r\n\t\t\t(forEach (first args) call)\r\n\t\t}\r\n\t\tret {\r\n\t\t(let (user-func) args mve this)\r\n\t\t{\r\n\t\t\t`pel replaceChild(pel,old_el,new_el)`\r\n\t\t\t(let e args)\r\n\t\t\t(let watchPool (cache []))\r\n\t\t\t(let Watch \r\n\t\t\t\t{\r\n\t\t\t\t\t(let w (apply util.Watcher args))\r\n\t\t\t\t\t(watchPool \r\n\t\t\t\t\t\t(extend w \r\n\t\t\t\t\t\t\t(watchPool)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t\tw\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t(let Cache \r\n\t\t\t\t{\r\n\t\t\t\t\t(util.Cache Watch (first args))\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t(let k (cache []))\r\n\t\t\t`用户函数返回`\r\n\t\t\t(let user-result \r\n\t\t\t\t(apply \r\n\t\t\t\t\tuser-func \r\n\t\t\t\t\t[\r\n\t\t\t\t\t\tValue 'util.Value\r\n\t\t\t\t\t\tArrayModel 'util.ArrayModel\r\n\t\t\t\t\t\tk {\r\n\t\t\t\t\t\t\t(let (str) args)\r\n\t\t\t\t\t\t\t(kvs-find1st (k) str)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tCache 'Cache\r\n\t\t\t\t\t\tWatch 'Watch\r\n\t\t\t\t\t\tDOM 'DOM\r\n\t\t\t\t\t]\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t`locsize部分`\r\n\t\t\t(let me  \r\n\t\t\t\t(reduce \r\n\t\t\t\t\tlocsize \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (init str) args)\r\n\t\t\t\t\t\t(let fun (kvs-find1st user-result str))\r\n\t\t\t\t\t\t(kvs-extend \r\n\t\t\t\t\t\t\tstr \r\n\t\t\t\t\t\t\t(if-run (exist? fun)\r\n\t\t\t\t\t\t\t\t{fun}\r\n\t\t\t\t\t\t\t\t{(util.Value 0)}\r\n\t\t\t\t\t\t\t) \r\n\t\t\t\t\t\t\tinit\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t[]\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t(let me\r\n\t\t\t\t(kvs-reduce user-result.out\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (init v k) args)\r\n\t\t\t\t\t\t(kvs-extend k v init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tme\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t(let \r\n\t\t\t\t(getElement c_k element-inits element-destroys) \r\n\t\t\t\t(Parse \r\n\t\t\t\t\te\r\n\t\t\t\t\tuser-result.element\r\n\t\t\t\t\t`Watch 给内部使用的`\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let w  (apply util.Watcher args))\r\n\t\t\t\t\t\t(watchPool \r\n\t\t\t\t\t\t\t(extend w \r\n\t\t\t\t\t\t\t\t(watchPool)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\tw\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmve\r\n\t\t\t\t\tk\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t(k c_k)\r\n\t\t\t(let \r\n\t\t\t\tuser-init (default user-result.init empty-fun)\r\n\t\t\t\tuser-destroy (default user-result.destroy empty-fun)\r\n\t\t\t)\r\n\t\t\t(kvs-reduce\r\n\t\t\t\t[ \r\n\t\t\t\t\tgetElement 'getElement\r\n\t\t\t\t\tinit {\r\n\t\t\t\t\t\t(forEach-run element-inits)\r\n\t\t\t\t\t\t(user-init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdestroy {\r\n\t\t\t\t\t\t(user-destroy)\r\n\t\t\t\t\t\t(forEach-run element-destroys)\r\n\t\t\t\t\t\t(forEach (watchPool) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t(let (w) args)\r\n\t\t\t\t\t\t\t\t(w.disable)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t\t{\r\n\t\t\t\t\t(let (init value k) args)\r\n\t\t\t\t\t(kvs-extend k value init)\r\n\t\t\t\t}\r\n\t\t\t\tme\r\n\t\t\t)\r\n\t\t}\r\n\t})\r\n\tret\r\n}",
  "lib-path/mve/javafx/index.lisp": "{\r\n\t(let\r\n\t\tutil (load '../util.lisp)\r\n\t\tParse (load '../parse.lisp)\r\n\t\tbuild-children-Factory (load '../build-children.lisp)\r\n\t\tlocsize [\r\n\t\t\twidth height left top right bottom\r\n\t\t]\r\n\r\n\t)\r\n\t(util.Exp\r\n\t\tlocsize\r\n\t\tDOM\r\n\t\t(Parse \r\n\t\t\tlocsize\r\n\t\t\t[\r\n\t\t\t\tlocsize {\r\n\r\n\t\t\t\t}\r\n\t\t\t\treplaceWith {\r\n\r\n\t\t\t\t}\r\n\t\t\t\tcreateTextNode {\r\n\r\n\t\t\t\t}\r\n\t\t\t\tbuildElement {\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t)\r\n\t)\r\n}",
  "lib-path/mve/parse.lisp": "\r\n(let \r\n\tbindFactory {\r\n\t\t(let (watch) args)\r\n\t\t{\r\n\t\t\t(let (value f) args)\r\n\t\t\t(if-run (type? value 'function)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(watch \r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\texp {\r\n\t\t\t\t\t\t\t\t\t(value)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tafter {\r\n\t\t\t\t\t\t\t\t\t(f (first args))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(f value)\r\n\t\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t} \r\n\tif-bind {\r\n\t\t(let (bind) args)\r\n\t\t{\r\n\t\t\t(let (value f) args)\r\n\t\t\t(if-run \r\n\t\t\t\t(exist? value)\r\n\t\t\t\t{\r\n\t\t\t\t\t(bind value f)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\tbuild-locsize {\r\n\t\t(let (locsize json fun) args)\r\n\t\t(forEach \r\n\t\t\tlocsize \r\n\t\t\t{\r\n\t\t\t\t(let \r\n\t\t\t\t\t(str) args\r\n\t\t\t\t\tvf (kvs-find1st json str)\r\n\t\t\t\t)\r\n\t\t\t\t(if-run (exist? vf)\r\n\t\t\t\t\t(fun str vf)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tadd-k {\r\n\t\t(let (k id obj) args)\r\n\t\t(if-run (exist? id)\r\n\t\t\t{\r\n\t\t\t\t(let old (kvs-find1st k id))\r\n\t\t\t\t(if-run (exist? old)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(log \"已经存在同名id\" id k old \"不能添加新的\" obj)\r\n\t\t\t\t\t\tk\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(kvs-extend id obj k)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{k}\r\n\t\t)\r\n\t}\r\n)\r\n{\r\n\t(let (locsize p) args)\r\n\t`对函数`\r\n\t(let ParseFun \r\n\t\t{\r\n\t\t\t`\r\n\t\t\t[\r\n\t\t\t\twatch \r\n\t\t\t\tinits \r\n\t\t\t\tdestroys \r\n\t\t\t\tmve \r\n\t\t\t]\r\n\t\t\t[\r\n\t\t\t\tk\r\n\t\t\t\tjson\r\n\t\t\t\tinits\r\n\t\t\t\tdestroys\r\n\t\t\t]\r\n\t\t\t`\r\n\t\t\t(let (x o) args)\r\n\t\t\t(let change (cache []))\r\n\t\t\t(x.watch\r\n\t\t\t\t[\r\n\t\t\t\t\texp { (o.json) }\r\n\t\t\t\t\tafter {\r\n\t\t\t\t\t\t(let (element) args)\r\n\t\t\t\t\t\t(let newObj \r\n\t\t\t\t\t\t\t((x.mve {[ element 'element]}) o.e)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t(let obj (change))\r\n\t\t\t\t\t\t(change newObj)\r\n\t\t\t\t\t\t(if-run (exist? obj)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t`非第一次生成`\r\n\t\t\t\t\t\t\t\t(o.e.replaceChild \r\n\t\t\t\t\t\t\t\t\to.e \r\n\t\t\t\t\t\t\t\t\t(obj.getElement)\r\n\t\t\t\t\t\t\t\t\t(newObj.getElement)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`mve生成，都是有init函数与destroy函数的`\r\n\t\t\t\t\t\t\t\t(obj.destroy)\r\n\t\t\t\t\t\t\t\t(newObj.init)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t)\r\n\t\t\t[\r\n\t\t\t\tchange 'change\r\n\t\t\t\t`绑定第一个生成`\r\n\t\t\t\tinits (extend (kvs-path (change) [init]) o.inits )\r\n\t\t\t\t`销毁最后一个`\r\n\t\t\t\tdestroys (extend \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(kvs-path-run (change) [destroy])\r\n\t\t\t\t\t} \r\n\t\t\t\t\to.destroys\r\n\t\t\t\t) \r\n\t\t\t]\r\n\t\t}\r\n\t)\r\n\t`对列表`\r\n\t(let ParseObject {\r\n\t\t\t`\r\n\t\t\t[\r\n\t\t\t\twatch \r\n\t\t\t\tmve\r\n\t\t\t\tbindMap\r\n\t\t\t\tbindEvent\r\n\t\t\t\tif-bind\r\n\t\t\t]\r\n\t\t\t[\r\n\t\t\t\tjson\r\n\t\t\t\tk \r\n\t\t\t\tinits \r\n\t\t\t\tdestroys \r\n\t\t\t]\r\n\t\t\t`\r\n\t\t\t(let \r\n\t\t\t\t(x o) args\r\n\t\t\t\tjson (default o.json \"\")\r\n\t\t\t)\r\n\t\t\t(if-run (type? json 'list)\r\n\t\t\t\t{\r\n\t\t\t\t\t`列表情况，对应js中字典`\r\n\t\t\t\t\t(if-run (type? json.type 'string)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\tobj (p.buildElement x o)\r\n\t\t\t\t\t\t\t\te obj.element\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t`绑定locsize`\r\n\t\t\t\t\t\t\t(build-locsize locsize o \r\n\t\t\t\t\t\t\t\t{(let (str vf) args)\r\n\t\t\t\t\t\t\t\t\t(x.bind vf {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.locsize e str v)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(p.makeUpElement e x o.json)\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\telement 'e\r\n\t\t\t\t\t\t\t\tk (add-k obj.k json.id e)\r\n\t\t\t\t\t\t\t\tinits 'o.inits\r\n\t\t\t\t\t\t\t\tdestroys 'o.destroys\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`自定义组件`\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\tobj ((json.type json.params) o.e)\r\n\t\t\t\t\t\t\t\te (obj.getElement)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t`绑定locsize`\r\n\t\t\t\t\t\t\t(build-locsize locsize json\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t\t\t(str vf) args\r\n\t\t\t\t\t\t\t\t\t \tef (default (kvs-find1st obj str) empty-fun)\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t(x.bind vf {\r\n\t\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t\t(ef v)\r\n\t\t\t\t\t\t\t\t\t\t\t(p.locsize e str v)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(p.makeUpElement e x o.json)\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\telement 'e\r\n\t\t\t\t\t\t\t\tk (add-k o.k json.id obj)\r\n\t\t\t\t\t\t\t\tinits (extend obj.init o.inits)\r\n\t\t\t\t\t\t\t\tdestroys (extend obj.destroy o.destroys)\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t`值节点`\r\n\t\t\t\t\t(p.createTextNode x o)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t)\r\n\t(let Parse {\r\n\t\t(let (x o) args)\r\n\t\t(if-run (type? o.json 'function)\r\n\t\t\t{\r\n\t\t\t\t(let vm (ParseFun x o))\r\n\t\t\t\t[\r\n\t\t\t\t\telement (kvs-path-run (vm.change) [getElement])\r\n\t\t\t\t\tk 'o.k\r\n\t\t\t\t\tinits 'vm.inits\r\n\t\t\t\t\tdestroys 'vm.destroys\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(ParseObject x o)\r\n\t\t\t}\r\n\t\t)\r\n\t})\r\n\t{\r\n\t\t(let \r\n\t\t\t(e json watch mve k) args\r\n\t\t\tbind (bindFactory watch)\r\n\t\t\tx [\r\n\t\t\t\tParse 'Parse\r\n\t\t\t\twatch 'watch \r\n\t\t\t\tmve 'mve\r\n\t\t\t\tbind 'bind\r\n\t\t\t\tif-bind (if-bind bind)\r\n\t\t\t]\r\n\t\t\to [\r\n\t\t\t\te 'e\r\n\t\t\t\tjson 'json\r\n\t\t\t\tk [] `无副作用的处理`\r\n\t\t\t\tinits [] \r\n\t\t\t\tdestroys [] \r\n\t\t\t]\r\n\t\t)\r\n\t\t(if-run (type? o.json 'function)\r\n\t\t\t{\r\n\t\t\t\t`function`\r\n\t\t\t\t(let vm (ParseFun x o))\r\n\t\t\t\t(list\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(kvs-path-run (vm.change) [getElement])\r\n\t\t\t\t\t}\r\n\t\t\t\t\t[]\r\n\t\t\t\t\tvm.inits\r\n\t\t\t\t\tvm.destroys\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(let vm (ParseObject x o))\r\n\t\t\t\t(list\r\n\t\t\t\t\t{vm.element}\r\n\t\t\t\t\tvm.k\r\n\t\t\t\t\tvm.inits\r\n\t\t\t\t\tvm.destroys\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}",
  "lib-path/mve/util.lisp": "\r\n\r\n\r\n(let Dep-target (cache []))\r\n\r\n(let Dep ({\r\n\t\t(let uid (cache 0))\r\n\t\t{\r\n\t\t\t(let subs  (cache []))\r\n\t\t\t`subs中已经包含`\r\n\t\t\t(let contain {\r\n\t\t\t\t(let (target) args)\r\n\t\t\t\t(some (subs) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (sub) args)\r\n\t\t\t\t\t\t(eq sub target)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t})\r\n\t\t\t(uid (+ (uid) 1))\r\n    \t\t[\r\n    \t\t\tdepend {\r\n    \t\t\t\t(if-run (exist? (Dep-target))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t \t(if-run (contain (Dep-target))\r\n\t\t\t\t\t\t \t\t{\r\n\t\t\t\t\t\t \t\t\t`一个watch包含两个观察节点时`\r\n\t\t\t\t\t\t \t\t\t`(log '已经包含了)`\r\n\t\t\t\t\t\t \t\t}\r\n\t\t\t\t\t\t \t\t{\r\n\t\t\t\t\t\t \t\t\t(subs \r\n\t\t\t\t\t\t \t\t\t\t(extend \r\n\t\t\t\t\t\t \t\t\t\t\t(Dep-target) \r\n\t\t\t\t\t\t \t\t\t\t\t(subs)\r\n\t\t\t\t\t\t \t\t\t\t)\r\n\t\t\t\t\t\t \t\t\t)\r\n\t\t\t\t\t\t \t\t}\r\n\t\t\t\t\t\t \t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n    \t\t\t}\r\n    \t\t\tnotify {\r\n    \t\t\t\t(let old_subs (subs))\r\n    \t\t\t\t(subs [])\r\n\t\t\t\t\t`\r\n\t\t\t\t\t\t调用每个Watcher的update\r\n\t\t\t\t\t\t每个Watcher将Dep-Target设置成自己\r\n\t\t\t\t\t\tWatcher计算期间，所有依赖的Value进行depend，每个Value将这个Watcher加入自己的通知链\r\n\t\t\t\t\t\t本值节点通知期间，重新收集通知链。而其它值节点，可能不需要收集（已经存在）\r\n\t\t\t\t\t`\r\n    \t\t\t\t(forEach old_subs call)\r\n    \t\t\t}\r\n    \t\t\tid (uid)\r\n    \t\t]\r\n\t\t}\r\n\t})\r\n\t`值节点`\r\n\tValue {\r\n\t\t(let dep (Dep))\r\n\t\t(let v (apply cache args))\r\n\t\t{\r\n\t\t\t(let xs args)\r\n\t\t\t(if-run (exist? xs)\r\n\t\t\t\t{\r\n\t\t\t\t\t(if-run (exist? (Dep-target))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(log '计算期间不允许修改)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(v (first xs))\r\n\t\t\t\t\t\t\t(dep.notify)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t(dep.depend)\r\n\t\t\t\t\t(v)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\r\n\tArrayModel {\r\n\t\t(let \r\n\t\t\tarray (cache args)\r\n\t\t\tviews (cache [])\r\n\t\t)\r\n\t\t[\r\n\t\t\tlist {\r\n\t\t\t\t(array)\r\n\t\t\t}\r\n\t\t\taddView {\r\n\t\t\t\t(views (extend (first args) (views)))\r\n\t\t\t}\r\n\t\t\tremoveView {\r\n\t\t\t\t(let index (indexOf (views) (first args)))\r\n\t\t\t\t(if-run (< -1 index)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(views (splice (views) index 1))\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\r\n\t\t\tinsert {\r\n\t\t\t\t(let (index row) args)\r\n\t\t\t\t(array (splice (array) index 0 row))\r\n\t\t\t\t(forEach (views) {\r\n\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t(view.insert index row)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\tremove {\r\n\t\t\t\t(let (index) args)\r\n\t\t\t\t(array (splice (array) index 1))\r\n\t\t\t\t(forEach (views) {\r\n\t\t\t\t\t(let (view) args)\r\n\t\t\t\t\t(view.remove index)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t]\r\n\t}\r\n\tWatcher ({\r\n\t\t(let uid (cache 0))\r\n\t\t{\r\n\t\t\t(let (p) args)\r\n\t\t\t(let  \r\n\t\t\t\tbefore  (default p.before empty-fun) \r\n\t\t\t\tafter (default p.after empty-fun)\r\n\t\t\t)\r\n\r\n\t\t\t(let enable (cache true))\r\n\t\t\t(uid (+ (uid) 1))\r\n\t\t\t(let id (uid))\r\n\t\t\t(let update \r\n\t\t\t\t{\r\n\t\t\t\t\t(let update this)\r\n\t\t\t\t\t(if-run (enable)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let bo (before))\r\n\t\t\t\t\t\t\t(Dep-target update)\r\n\t\t\t\t\t\t\t(let ao (p.exp bo))\r\n\t\t\t\t\t\t\t(Dep-target [])\r\n\t\t\t\t\t\t\t(after ao)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t(update)\r\n\t\t\t[\r\n\t\t\t\tid 'id\r\n\t\t\t\tupdate 'update\r\n\t\t\t\tdisable {\r\n\t\t\t\t\t(enable false)\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t}\r\n\t})\r\n\r\n\tCache {\r\n\t\t(let dep (Dep))\r\n\t\t(let (watch func) args)\r\n\t\t(let cache (cache []))\r\n\t\t(watch [\r\n\t\t\texp {\r\n\t\t\t\t(cache (func ))\r\n\t\t\t\t(dep.notify)\r\n\t\t\t}\r\n\t\t])\r\n\t\t{\r\n\t\t\t(dep.depend)\r\n\t\t\t(cache)\r\n\t\t}\r\n\t}\r\n)\r\n\r\n[\r\n\tValue 'Value\r\n\r\n\tWatcher 'Watcher\r\n\r\n\tArrayModel 'ArrayModel\r\n\r\n\tCache 'Cache\r\n]",
  "lib-path/mve/winform/index.lisp": "{\r\n\t(let\r\n\t\t(Factory) args\r\n\t\tutil (load '../util.lisp)\r\n\t\texp (load '../exp.lisp)\r\n\t\tParse (load '../parse.lisp)\r\n\t\tbuild-children-Factory {\r\n\t\t\t(let p args)\r\n\t\t\t((load '../build-children.lisp)\t\r\n\t\t\t\t[\r\n\t\t\t\t\tkey 'p.key\r\n\t\t\t\t\tValue 'util.Value\r\n\t\t\t\t\tWatcher 'util.Watcher\r\n\t\t\t\t\tbefore 'p.before\r\n\t\t\t\t\tafter 'p.after\r\n\t\t\t\t\tappendChild 'p.appendChild\r\n\t\t\t\t\tremoveChild 'p.removeChild\r\n\t\t\t\t\tinsertChildBefore 'p.insertChildBefore\r\n\t\t\t\t]\r\n\t\t\t)\r\n\t\t}\r\n\t\tDOM (Factory build-children-Factory)\r\n\t\tlocsize [\r\n\t\t\twidth height left top right bottom\r\n\t\t]\r\n\t\tbindKV {\r\n\t\t\t(let (bind key value f) args)\r\n\t\t\t(bind value {\r\n\t\t\t\t\t(f key \r\n\t\t\t\t\t\t(first args)\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t} \r\n\t\tbindMap {\r\n\t\t\t(let (bind map f) args)\r\n\t\t\t(if-run (exist? map)\r\n\t\t\t\t{\r\n\t\t\t\t\t(kvs-forEach map \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v k) args)\r\n\t\t\t\t\t\t\t(bindKV bind k v f)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t} \r\n\t\tbindEvent {\r\n\t\t\t(let (map f) args)\r\n\t\t\t(if-run (exist? map)\r\n\t\t\t\t{\r\n\t\t\t\t\t(kvs-forEach map \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v k) args)\r\n\t\t\t\t\t\t\t(f k v)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t)\r\n\t(exp\r\n\t\tlocsize\r\n\t\tDOM\r\n\t\t(Parse\r\n\t\t\tlocsize\r\n\t\t\t[\r\n\t\t\t\tlocsize {\r\n\r\n\t\t\t\t}\r\n\t\t\t\tcreateTextNode {\r\n\t\t\t\t\t(log \"未实现，请尽量避免createTextNode\")\r\n\t\t\t\t}\r\n\t\t\t\tbuildElement {\r\n\t\t\t\t\t(let (x o) args)\r\n\t\t\t\t\t(DOM.build o.json.type x o)\r\n\t\t\t\t}\r\n\t\t\t\tmakeUpElement {\r\n\t\t\t\t\t(let (e x json) args)\r\n\t\t\t\t\t(bindMap x.bind json.attr\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.attr (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t(bindEvent json.event \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.event (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`内部字符`\r\n\t\t\t\t\t(x.if-bind json.text \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(apply DOM.text (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`内部值`\r\n\t\t\t\t\t(x.if-bind json.value\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t(apply DOM.value (extend e args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t)\r\n\t)\r\n}",
  "lib-path/mve_old/build-children.lisp": "\r\n\r\n{\r\n\t`从util里调入`\r\n\t(let \r\n\t\t(Value Watcher DOM nokey) args\r\n\t    build {\r\n\t\t\t`下面调入`\r\n\t\t\t(let (repeat mve) args)\r\n\t\t\t{\r\n\t\t\t\t`最终调入`\r\n\t\t\t\t(let (row i) args)\r\n\t\t\t\t(let \r\n\t\t\t\t\to [ \r\n\t\t\t\t\t\tdata (Value row) \r\n\t\t\t\t\t\tindex (Value i) \r\n\t\t\t\t\t] \r\n\t\t\t\t)\r\n\t\t\t\t[ \r\n\t\t\t\t\trow 'o\r\n\t\t\t\t\tobj (mve \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\telement {\r\n\t\t\t\t\t\t\t\t\t\t(apply repeat o)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t}\r\n\t)\r\n\t{\r\n\t\t(let \r\n\t\t\t(pel children inits destroys mve) args\r\n\t\t\t`是否初始化`\r\n\t\t\tisInit (cache false)\r\n\t\t\t`未初始化时缓存值`\r\n\t\t\tc-inits (cache [])\r\n\t\t\t(bc-after bc-destroy) \r\n\t\t\t\t(nokey \r\n\t\t\t\t\t[\r\n\t\t\t\t\t\tbuild (build children.repeat mve)\r\n\t\t\t\t\t\tafter {\r\n\t\t\t\t\t\t\t(let (value) args)\r\n\t\t\t\t\t\t\t(let init value.obj.init)\r\n\t\t\t\t\t\t\t(if-run (isInit)\r\n\t\t\t\t\t\t\t\t{(init)}\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t(c-inits (extend init (c-inits)))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdate-data {\r\n\t\t\t\t\t\t\t(let (value v) args)\r\n\t\t\t\t\t\t\t(value.row.data v)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdestroy {\r\n\t\t\t\t\t\t\t(let (value) args)\r\n\t\t\t\t\t\t\t(value.obj.destroy)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tappendChild {\r\n\t\t\t\t\t\t\t(let (value) args)\r\n\t\t\t\t\t\t\t(DOM.appendChild pel (value.obj.getElement))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tremoveChild {\r\n\t\t\t\t\t\t\t(let (value) args)\r\n\t\t\t\t\t\t\t(DOM.removeChild pel (value.obj.getElement))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t)\r\n\t\t\t`Array的计算观察`\r\n\t\t\twatch \r\n\t\t\t\t(Watcher \r\n\t\t\t\t\t[\r\n\t\t\t\t\t\texp {\r\n\t\t\t\t\t\t\t(children.array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tafter {\r\n\t\t\t\t\t\t\t(bc-after (first args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t)\r\n\t\t)\r\n\t\t(list \r\n\t\t\t`inits`\r\n\t\t\t(extend \r\n\t\t\t\t{\r\n\t\t\t\t\t(forEach (c-inits)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t((first args))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t\t(c-inits [])\r\n\t\t\t\t\t(isInit true)\r\n\t\t\t\t} \r\n\t\t\t\tinits\r\n\t\t\t) \r\n\t\t\t`destroys`\r\n\t\t\t(extend \r\n\t\t\t\t{\r\n\t\t\t\t\t(watch.disable)\r\n\t\t\t\t\t(bc-destroy)\r\n\t\t\t\t} \r\n\t\t\t\tdestroys\r\n\t\t\t)\r\n\t\t)\r\n\t}\r\n}",
  "lib-path/mve_old/index.lisp": "{\r\n\t(let \r\n\t\t(DOM) args\r\n\t\tutil  (load './util.lisp)\r\n\t\tParse (load './parse.lisp)\r\n\t\tbuild-children (load './build-children.lisp)\r\n\t\tnokey (load './nokey.lisp)\r\n\t)\r\n\t(util.Exp \r\n\t\t(Parse\r\n\t\t\tDOM\r\n\t\t\t(build-children\r\n\t\t\t\tutil.Value\r\n\t\t\t\tutil.Watcher\r\n\t\t\t\tDOM\r\n\t\t\t\tnokey\r\n\t\t\t)\r\n\t\t\tutil.locsize\r\n\t\t)\r\n\t\tDOM\r\n\t)\r\n}",
  "lib-path/mve_old/nokey.lisp": "\r\n{\r\n\t`与js的array不同，使用倒置的顺序`\r\n\t`build after update-data destroy appendChild removeChild`\r\n\t(let (p) args)\r\n\t(let \r\n\t\tcaches (cache [])\r\n\t\tviews (cache [])\r\n\t\tupdate-views {\r\n\t\t\t(let (array) args)\r\n\t\t\t(\r\n\t\t\t\t{\r\n\t\t\t\t\t(let (vs as) args circle this)\r\n\t\t\t\t\t(if-run (exist? vs)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v ...vs) vs (a ...as) as)\r\n\t\t\t\t\t\t\t(p.update-data v a)\r\n\t\t\t\t\t\t\t(circle vs as)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t} \r\n\t\t\t\t(views) array\r\n\t\t\t)\r\n\t\t}\r\n\t\tlen-c {\r\n\t\t\t(len \r\n\t\t\t\t((first args))\r\n\t\t\t)\r\n\t\t}\r\n\t)\r\n\t[\r\n\t\t`after` \r\n\t\t{\r\n\t\t\t(let (array) args)\r\n\t\t\t(if-run \r\n\t\t\t\t(< (len array)(len-c views) )\r\n\t\t\t\t{\r\n\t\t\t\t\t`多出的`\r\n\t\t\t\t\t(let more (slice-from (views) (len array)))\r\n\t\t\t\t\t`移除视图上的元素`\r\n\t\t\t\t\t(forEach more p.removeChild)\r\n\t\t\t\t\t`更新视图上数据`\r\n\t\t\t\t\t(views (slice-to (views) (len array)))\r\n\t\t\t\t\t(update-views array)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t(if-run \r\n\t\t\t\t\t\t(< (len array) (len-c caches))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`向caches上增加`\r\n\t\t\t\t\t\t\t(let new-view (slice-to (caches) (len array)))\r\n\t\t\t\t\t\t\t(let more (slice-from new-view (len-c views)))\r\n\t\t\t\t\t\t\t(forEach more p.appendChild)\r\n\t\t\t\t\t\t\t(views new-view)\r\n\t\t\t\t\t\t\t(update-views array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`从caches向视图上增加`\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\tviews-len (len-c views)\r\n\t\t\t\t\t\t\t\tmore (slice-from (caches) views-len)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(forEach more p.appendChild)\r\n\t\t\t\t\t\t\t(views (caches))\r\n\t\t\t\t\t\t\t(update-views array)\r\n\t\t\t\t\t\t\t`新增加`\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\tc-l  (len-c caches)\r\n\t\t\t\t\t\t\t\tmore (slice-from array c-l)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(let (more-k) (reduce more\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t\t\t\t((init i) a) args\r\n\t\t\t\t\t\t\t\t\t\t\tv (p.build a i)\r\n\t\t\t\t\t\t\t\t\t\t\ti (+ i c-l 1)\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t(p.appendChild v)\r\n\t\t\t\t\t\t\t\t\t\t(p.after v)\r\n\t\t\t\t\t\t\t\t\t\t`因为把新增加的追加到后面了`\r\n\t\t\t\t\t\t\t\t\t\t(list \r\n\t\t\t\t\t\t\t\t\t\t\t(extend v init)\r\n\t\t\t\t\t\t\t\t\t\t\ti\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t[[] 'views-len]\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(caches (combine-two (caches) (reverse more-k)))\r\n\t\t\t\t\t\t\t(views (caches))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t\t`destroy`\r\n\t\t{\r\n\t\t\t(forEach (caches) p.destroy)\r\n\t\t}\r\n\t]\r\n}",
  "lib-path/mve_old/parse.lisp": "\r\n(let \r\n\tbind {\r\n\t\t(let (watch value f) args)\r\n\t\t(if-run (type? value 'function)\r\n\t\t\t\t{\r\n\t\t\t\t\t(watch \r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\texp {\r\n\t\t\t\t\t\t\t\t(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tafter {\r\n\t\t\t\t\t\t\t\t(f (first args))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t(f value)\r\n\t\t\t\t}\r\n\t\t)\r\n\t} \r\n\tbindKV {\r\n\t\t(let (watch key value f) args)\r\n\t\t(bind watch value {\r\n\t\t\t\t(f key \r\n\t\t\t\t\t(first args)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t} \r\n\tbindMap {\r\n\t\t(let (watch map f) args)\r\n\t\t(if-run (exist? map)\r\n\t\t\t\t{\r\n\t\t\t\t\t(kvs-forEach map \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v k) args)\r\n\t\t\t\t\t\t\t(bindKV watch k v f)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t)\r\n\t} \r\n\tbindEvent {\r\n\t\t(let (map f) args)\r\n\t\t(if-run (exist? map)\r\n\t\t\t\t{\r\n\t\t\t\t\t(kvs-forEach map \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let (v k) args)\r\n\t\t\t\t\t\t\t(f k v)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t)\r\n\t} \r\n\tif-bind {\r\n\t\t(let (watch value f) args)\r\n\t\t(if-run \r\n\t\t\t(exist? value)\r\n\t\t\t{\r\n\t\t\t\t(bind watch value f)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\tbuild-locsize {\r\n\t\t(let (locsize json fun) args)\r\n\t\t(forEach \r\n\t\t\tlocsize \r\n\t\t\t{\r\n\t\t\t\t(let \r\n\t\t\t\t\t(str) args\r\n\t\t\t\t\tvf (kvs-find1st json str)\r\n\t\t\t\t)\r\n\t\t\t\t(if-run (exist? vf)\r\n\t\t\t\t\t(fun str vf)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n\t`供后面inits和destroys使用`\r\n\tforEach-run {\r\n\t\t(let (array) args)\r\n\t\t{\r\n\t\t\t(forEach array\r\n\t\t\t\t{\r\n\t\t\t\t\t((first args))\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n)\r\n{\r\n\t(let (DOM build-children locsize) args)\r\n\t`对函数`\r\n\t(let Parse-fun \r\n\t\t{\r\n\t\t\t(let (fun watch inits destroys mve) args)\r\n\t\t\t(let change (cache []))\r\n\t\t\t(watch\r\n\t\t\t\t[\r\n\t\t\t\t\texp 'fun \r\n\t\t\t\t\tafter {\r\n\t\t\t\t\t\t(let (element) args)\r\n\t\t\t\t\t\t(let newObj \r\n\t\t\t\t\t\t\t(mve \r\n\t\t\t\t\t\t\t\t{ \r\n\t\t\t\t\t\t\t\t\t[ element 'element] \r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t(let obj (change))\r\n\t\t\t\t\t\t(change newObj)\r\n\t\t\t\t\t\t(if-run (exist? obj)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t`非第一次生成`\r\n\t\t\t\t\t\t\t\t(DOM.replaceWith \r\n\t\t\t\t\t\t\t\t\t(obj.getElement)\r\n\t\t\t\t\t\t\t\t\t(newObj.getElement)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`mve生成，都是有init函数与destroy函数的`\r\n\t\t\t\t\t\t\t\t(obj.destroy)\r\n\t\t\t\t\t\t\t\t(newObj.init)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t)\r\n\t\t\t(list \r\n\t\t\t\tchange \r\n\t\t\t\t`绑定第一个生成`\r\n\t\t\t\t(extend (kvs-path (change) [init]) inits ) \r\n\t\t\t\t`销毁最后一个`\r\n\t\t\t\t(extend \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(kvs-path-run (change) [destroy])\r\n\t\t\t\t\t} \r\n\t\t\t\t\tdestroys\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t}\r\n\t)\r\n\t`对列表`\r\n\t(let Parse {\r\n\t\t\t(let (json watch k inits destroys mve) args Parse this)\r\n\t\t\t(let json (default json \"\"))\r\n\t\t\t(if-run (type? json 'list)\r\n\t\t\t\t{\r\n\t\t\t\t\t`列表情况，对应js中字典`\r\n\t\t\t\t\t(let j json)\r\n\t\t\t\t\t(if-run (type? j.type 'function)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t`自定义组件`\r\n\t\t\t\t\t\t\t\t(let obj (j.type j.params))\r\n\t\t\t\t\t\t\t\t`绑定id`\r\n\t\t\t\t\t\t\t\t(if-run (exist? j.id)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(k (kvs-extend j.id obj (k)))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t(let e (obj.getElement))\r\n\t\t\t\t\t\t\t\t`绑定locsize`\r\n\t\t\t\t\t\t\t\t(build-locsize \r\n\t\t\t\t\t\t\t\t\tlocsize \r\n\t\t\t\t\t\t\t\t\tjson \r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t\t\t\t(str vf) args\r\n\t\t\t\t\t\t\t\t\t\t \tef (default (kvs-find1st obj str) empty-fun)\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t(bind \r\n\t\t\t\t\t\t\t\t\t\t\twatch \r\n\t\t\t\t\t\t\t\t\t\t\tvf \r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(ef v)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(DOM.locsize e str v)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t(list \r\n\t\t\t\t\t\t\t\t\te\r\n\t\t\t\t\t\t\t\t\t(extend obj.init inits)\r\n\t\t\t\t\t\t\t\t\t(extend obj.destroy destroys)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t`原生组件`\r\n\t\t\t\t\t\t\t\t(let e \r\n\t\t\t\t\t\t\t\t\t(DOM.createElement j.type)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`绑定id`\r\n\t\t\t\t\t\t\t\t(if-run (exist? j.id)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(k (kvs-extend j.id e (k)))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`attr属性`\r\n\t\t\t\t\t\t\t\t(bindMap watch j.attr \r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (k v) args)\r\n\t\t\t\t\t\t\t\t\t\t(DOM.attr e k v)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`style属性`\r\n\t\t\t\t\t\t\t\t(bindMap watch j.style\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (k v) args)\r\n\t\t\t\t\t\t\t\t\t\t(DOM.style e k v)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`动作`\r\n\t\t\t\t\t\t\t\t(bindEvent j.action\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (k v) args)\r\n\t\t\t\t\t\t\t\t\t\t(DOM.action e k v)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`内部字符`\r\n\t\t\t\t\t\t\t\t(if-bind watch j.text \r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t(DOM.text e v)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`内部值`\r\n\t\t\t\t\t\t\t\t(if-bind watch j.value\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t(DOM.value e v)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`innerHTML`\r\n\t\t\t\t\t\t\t\t(if-bind watch j.html\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t(DOM.html e v)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`children`\r\n\t\t\t\t\t\t\t\t(let (inits destroys) \r\n\t\t\t\t\t\t\t\t\t(if-run (str-eq 'kvs j.children-type)\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t`children-type是kvs，即repeat`\r\n\t\t\t\t\t\t\t\t\t\t\t(build-children e j.children inits destroys mve)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t`children是列表`\r\n\t\t\t\t\t\t\t\t\t\t\t(reduce j.children\r\n\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(let (ini child) args)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(let (inits destroys) ini)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(let (ce inits destroys) (Parse child watch k inits destroys mve))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(DOM.appendChild e ce)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(list inits destroys)\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t(list inits destroys)\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t`绑定locsize`\r\n\t\t\t\t\t\t\t\t(build-locsize \r\n\t\t\t\t\t\t\t\t\tlocsize \r\n\t\t\t\t\t\t\t\t\tjson \r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t(let (str vf) args)\r\n\t\t\t\t\t\t\t\t\t\t(bind \r\n\t\t\t\t\t\t\t\t\t\t\twatch \r\n\t\t\t\t\t\t\t\t\t\t\tvf \r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t(let (v) args)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(DOM.locsize e str v)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t(list e inits destroys)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t(if-run (type? json 'function)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`函数节点`\r\n\t\t\t\t\t\t\t(let \r\n\t\t\t\t\t\t\t\t(change inits destroys) (Parse-fun json watch inits destroys mve)\r\n\t\t\t\t\t\t\t\tobj (change)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(list \r\n\t\t\t\t\t\t\t\t(obj.getElement)\r\n\t\t\t\t\t\t\t\tinits\r\n\t\t\t\t\t\t\t\tdestroys\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`值节点`\r\n\t\t\t\t\t\t\t(list \r\n\t\t\t\t\t\t\t\t(DOM.createTextNode json)\r\n\t\t\t\t\t\t\t\tinits\r\n\t\t\t\t\t\t\t\tdestroys\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t)\r\n\t{\r\n\t\t(let \r\n\t\t\t(json watch k mve) args\r\n\t\t\tinits (cache []) \r\n\t\t\tdestroys (cache [])\r\n\t\t)\r\n\t\t(if-run (type? json 'function)\r\n\t\t\t{\r\n\t\t\t\t`function`\r\n\t\t\t\t(let (change inits destroys) (Parse-fun json watch [] [] mve))\r\n\t\t\t\t(list\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(kvs-path-run (change) [getElement])\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(forEach-run inits)\r\n\t\t\t\t\t(forEach-run destroys)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(let (el inits destroys) \r\n\t\t\t\t\t(Parse json watch k [] [] mve)\r\n\t\t\t\t)\r\n\t\t\t\t(list\r\n\t\t\t\t\t{el}\r\n\t\t\t\t\t(forEach-run inits)\r\n\t\t\t\t\t(forEach-run destroys)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}",
  "lib-path/mve_old/util.lisp": "\r\n\r\n\r\n(let Dep-target (cache []))\r\n\r\n(let Dep ({\r\n\t\t(let uid (cache 0))\r\n\t\t{\r\n\t\t\t(let subs  (cache []))\r\n\t\t\t`subs中已经包含`\r\n\t\t\t(let contain {\r\n\t\t\t\t(let (target) args)\r\n\t\t\t\t(some (subs) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (sub) args)\r\n\t\t\t\t\t\t(eq sub target)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t})\r\n\t\t\t(uid (+ (uid) 1))\r\n    \t\t[\r\n    \t\t\tdepend {\r\n    \t\t\t\t(if-run (exist? (Dep-target))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t \t(if-run (contain (Dep-target))\r\n\t\t\t\t\t\t \t\t{\r\n\t\t\t\t\t\t \t\t\t`一个watch包含两个观察节点时`\r\n\t\t\t\t\t\t \t\t\t`(log '已经包含了)`\r\n\t\t\t\t\t\t \t\t}\r\n\t\t\t\t\t\t \t\t{\r\n\t\t\t\t\t\t \t\t\t(subs \r\n\t\t\t\t\t\t \t\t\t\t(extend \r\n\t\t\t\t\t\t \t\t\t\t\t(Dep-target) \r\n\t\t\t\t\t\t \t\t\t\t\t(subs)\r\n\t\t\t\t\t\t \t\t\t\t)\r\n\t\t\t\t\t\t \t\t\t)\r\n\t\t\t\t\t\t \t\t}\r\n\t\t\t\t\t\t \t)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n    \t\t\t}\r\n    \t\t\tnotify {\r\n    \t\t\t\t(let old_subs (subs))\r\n    \t\t\t\t(subs [])\r\n\t\t\t\t\t`\r\n\t\t\t\t\t\t调用每个Watcher的update\r\n\t\t\t\t\t\t每个Watcher将Dep-Target设置成自己\r\n\t\t\t\t\t\tWatcher计算期间，所有依赖的Value进行depend，每个Value将这个Watcher加入自己的通知链\r\n\t\t\t\t\t\t本值节点通知期间，重新收集通知链。而其它值节点，可能不需要收集（已经存在）\r\n\t\t\t\t\t`\r\n    \t\t\t\t(forEach old_subs call)\r\n    \t\t\t}\r\n    \t\t\tid (uid)\r\n    \t\t]\r\n\t\t}\r\n\t})\r\n\t`值节点`\r\n\tValue {\r\n\t\t(let dep (Dep))\r\n\t\t(let v (apply cache args))\r\n\t\t{\r\n\t\t\t(let xs args)\r\n\t\t\t(if-run (exist? xs)\r\n\t\t\t\t{\r\n\t\t\t\t\t(if-run (exist? (Dep-target))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(log '计算期间不允许修改)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(v (first xs))\r\n\t\t\t\t\t\t\t(dep.notify)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t\t{\r\n\t\t\t\t\t(dep.depend)\r\n\t\t\t\t\t(v)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\tWatcher ({\r\n\t\t(let uid (cache 0))\r\n\t\t{\r\n\t\t\t(let (p) args)\r\n\t\t\t(let  \r\n\t\t\t\tbefore  (default p.before empty-fun) \r\n\t\t\t\tafter (default p.after empty-fun)\r\n\t\t\t)\r\n\r\n\t\t\t(let enable (cache true))\r\n\t\t\t(uid (+ (uid) 1))\r\n\t\t\t(let id (uid))\r\n\t\t\t(let update \r\n\t\t\t\t{\r\n\t\t\t\t\t(let update this)\r\n\t\t\t\t\t(if-run (enable)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(let bo (before))\r\n\t\t\t\t\t\t\t(Dep-target update)\r\n\t\t\t\t\t\t\t(let ao (p.exp bo))\r\n\t\t\t\t\t\t\t(Dep-target [])\r\n\t\t\t\t\t\t\t(after ao)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t)\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t(update)\r\n\t\t\t[\r\n\t\t\t\tid 'id\r\n\t\t\t\tupdate 'update\r\n\t\t\t\tdisable {\r\n\t\t\t\t\t(enable false)\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t}\r\n\t})\r\n\r\n\tCache {\r\n\t\t(let dep (Dep))\r\n\t\t(let (watch func) args)\r\n\t\t(let cache (cache []))\r\n\t\t(watch [\r\n\t\t\texp {\r\n\t\t\t\t(cache (func ))\r\n\t\t\t\t(dep.notify)\r\n\t\t\t}\r\n\t\t])\r\n\t\t{\r\n\t\t\t(dep.depend)\r\n\t\t\t(cache)\r\n\t\t}\r\n\t}\r\n\tlocsize [\r\n\t\twidth height left top right bottom\r\n\t]\r\n)\r\n\r\n[\r\n\tValue (quote Value)\r\n\r\n\tWatcher (quote Watcher)\r\n\r\n\tCache (quote Cache)\r\n\r\n\tlocsize (quote locsize)\r\n\r\n\tExp {\r\n\t\t(let (Parse DOM) args)\r\n\t\t(let ret {\r\n\t\t\t(let (user-func) args mve this)\r\n\t\t\t(let watchPool (cache []))\r\n\t\t\t(let Watch \r\n\t\t\t\t{\r\n\t\t\t\t\t(let w (apply Watcher args))\r\n\t\t\t\t\t(watchPool \r\n\t\t\t\t\t\t(extend w \r\n\t\t\t\t\t\t\t(watchPool)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t\tw\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t(let Cache \r\n\t\t\t\t{\r\n\t\t\t\t\t(Cache Watch (first args))\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t(let k (cache []))\r\n\t\t\t`用户函数返回`\r\n\t\t\t(let user-result \r\n\t\t\t\t(apply \r\n\t\t\t\t\tuser-func \r\n\t\t\t\t\t[\r\n\t\t\t\t\t\tValue 'Value\r\n\t\t\t\t\t\tk {\r\n\t\t\t\t\t\t\t(let (str) args)\r\n\t\t\t\t\t\t\t(kvs-find1st (k) str)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tCache 'Cache\r\n\t\t\t\t\t\tWatch 'Watch\r\n\t\t\t\t\t\tDOM 'DOM\r\n\t\t\t\t\t]\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t`locsize部分`\r\n\t\t\t(let me  \r\n\t\t\t\t(reduce \r\n\t\t\t\t\tlocsize \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (init str) args)\r\n\t\t\t\t\t\t(let fun (kvs-find1st user-result str))\r\n\t\t\t\t\t\t(kvs-extend \r\n\t\t\t\t\t\t\tstr \r\n\t\t\t\t\t\t\t(if-run (exist? fun)\r\n\t\t\t\t\t\t\t\t{fun}\r\n\t\t\t\t\t\t\t\t{(Value 0)}\r\n\t\t\t\t\t\t\t) \r\n\t\t\t\t\t\t\tinit\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t[]\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t(let me\r\n\t\t\t\t(kvs-reduce user-result.out\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let (init v k) args)\r\n\t\t\t\t\t\t(kvs-extend k v init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tme\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t(let \r\n\t\t\t\t(getElement element-init element-destroy) \r\n\t\t\t\t(Parse \r\n\t\t\t\t\tuser-result.element\r\n\t\t\t\t\t`Watch 给内部使用的`\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t(let w  (apply Watcher args))\r\n\t\t\t\t\t\t(watchPool \r\n\t\t\t\t\t\t\t(extend w \r\n\t\t\t\t\t\t\t\t(watchPool)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\tw\r\n\t\t\t\t\t}\r\n\t\t\t\t\tk\r\n\t\t\t\t\tmve\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t\t(let \r\n\t\t\t\tuser-init (default user-result.init empty-fun)\r\n\t\t\t\tuser-destroy (default user-result.destroy empty-fun)\r\n\t\t\t)\r\n\t\t\t(kvs-reduce\r\n\t\t\t\t[ \r\n\t\t\t\t\tgetElement 'getElement\r\n\t\t\t\t\tinit {\r\n\t\t\t\t\t\t(element-init)\r\n\t\t\t\t\t\t(user-init)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdestroy {\r\n\t\t\t\t\t\t(user-destroy)\r\n\t\t\t\t\t\t(element-destroy)\r\n\t\t\t\t\t\t(forEach (watchPool) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t(let (w) args)\r\n\t\t\t\t\t\t\t\t(w.disable)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t\t{\r\n\t\t\t\t\t(let (init value k) args)\r\n\t\t\t\t\t(kvs-extend k value init)\r\n\t\t\t\t}\r\n\t\t\t\tme\r\n\t\t\t)\r\n\t\t})\r\n\t\tret\r\n\t}\r\n]\r\n",
  "index/S-Lisp/index/a.lisp": "{\r\n\t(log '我是A文件)\r\n\r\n\t(let x (load './b.lisp))\r\n\t(if-run (> 9 8)\r\n\t\t\t{\r\n\t\t\t\t(log '小于98)\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(log '大于98)\r\n\t\t\t}\r\n\t)\r\n\t(x)\r\n\t[\r\n\t\ta 98 b {\r\n\t\t\t(log 'as文件返回)\r\n\t\t}\r\n\t]\r\n}",
  "index/S-Lisp/index/b.lisp": "(log '我是B文件)\r\n(log (reduce [a b c]\r\n\t{\r\n\t\t(let (init v i) args)\r\n\t\t(extend v init)\r\n\t}\r\n\t[]\r\n))\r\n{\r\n\t(log 'b文件返回)\r\n}",
  "index/S-Lisp/index/ca.lisp": "{\r\n\t(let (a b c ) args)\r\n\t(mve\r\n\t\t{\r\n\t\t\t(let me args)\r\n\t\t\t(let ak (me.Value 98))\r\n\t\t\t[\r\n\t\t\t\tinit {\r\n\t\t\t\t\t(log '我是子组件初始化)\r\n\t\t\t\t}\r\n\t\t\t\tdestroy {\r\n\t\t\t\t\t(log '我是子组件销毁)\r\n\t\t\t\t}\r\n\t\t\t\telement {\r\n\t\t\t\t\t[\r\n\t\t\t\t\t\ttype div\r\n\t\t\t\t\t\tattr [\r\n\t\t\t\t\t\t\ta 0 b 1\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\tchildren [\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\ttype button\r\n\t\t\t\t\t\t\t\tevent [\r\n\t\t\t\t\t\t\t\t\tclick {\r\n\t\t\t\t\t\t\t\t\t\t(ak (+ (ak) 1 ))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\ttext (str-join [我是组件 (ak)])\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t]\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t}\r\n\t)\r\n}",
  "index/S-Lisp/index/index.lisp": "{\r\n\t(let x {\r\n\t\t(log 9)\r\n\t})\r\n\t(quote 88)\r\n\t(log 988 7)\t\r\n\t(let a (load './a.lisp) b (load './b.lisp))\r\n\t(let x (a))\r\n\t(x.b)\r\n\t{\r\n\t\t(log 98 7)\t\r\n\t}\r\n\t(mve\r\n\t\t{\r\n\t\t\t(let me args)\r\n\t\t\t(let a (me.Value 9))\r\n\t\t\t(log (a))\r\n\t\t\t(a (+ (a) 1))\r\n\t\t\t(log (a))\r\n\t\t\t(let array (me.Value [a b c d e f g h]))\r\n\t\t\t[\r\n\t\t\t\telement [\r\n\t\t\t\t\ttype div\r\n\t\t\t\t\tevent [\r\n\t\t\t\t\t\tclick {\r\n\t\t\t\t\t\t\t(log 98)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t\tattr [\r\n\t\t\t\t\t\ta 98 \r\n\t\t\t\t\t\tb 89\r\n\t\t\t\t\t]\r\n\t\t\t\t\tchildren [\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype div\r\n\t\t\t\t\t\t\tattr [\r\n\t\t\t\t\t\t\t\tcolor red\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\ttext 你\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype div\r\n\t\t\t\t\t\t\tstyle [\r\n\t\t\t\t\t\t\t\tcolor red\r\n\t\t\t\t\t\t\t\tbackground-color gray\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\ttext 我\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype button\r\n\t\t\t\t\t\t\ttext {\r\n\t\t\t\t\t\t\t\t(a)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tevent [\r\n\t\t\t\t\t\t\t\tclick {\r\n\t\t\t\t\t\t\t\t\t(a (+ (a) 1))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype button\r\n\t\t\t\t\t\t\ttext {\r\n\t\t\t\t\t\t\t\t(+ (a) 1)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tevent [\r\n\t\t\t\t\t\t\t\tclick {\r\n\t\t\t\t\t\t\t\t\t(a (+ (a) 2))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\ttype div\r\n\t\t\t\t\t\t\t\ttext (str-join [来吧 (a)])\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype ul\r\n\t\t\t\t\t\t\tchildren [\r\n\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\ttype li\r\n\t\t\t\t\t\t\t\t\ttext 试用S-Lisp\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\ttype li\r\n\t\t\t\t\t\t\t\t\ttext 试用mve\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype input\r\n\t\t\t\t\t\t\tvalue 'a\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype (load './ca.lisp)\r\n\t\t\t\t\t\t\tparams [\r\n\t\t\t\t\t\t\t\tx y z\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\"感谢支持\"\r\n\r\n\t\t\t\t\t\t'测试children-repeat\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype div\r\n\t\t\t\t\t\t\tchildren [\r\n\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\ttype input\r\n\t\t\t\t\t\t\t\t\tid ipx\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\ttype button\r\n\t\t\t\t\t\t\t\t\ttext {\r\n\t\t\t\t\t\t\t\t\t\t(str-join [(len (array)) 条记录])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tevent [\r\n\t\t\t\t\t\t\t\t\t\tclick {\r\n\t\t\t\t\t\t\t\t\t\t\t(let el (me.k 'ipx))\r\n\t\t\t\t\t\t\t\t\t\t\t(let v (me.DOM.value el ))\r\n\t\t\t\t\t\t\t\t\t\t\t(if-run (= 0 (str-length (str-trim v)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(me.DOM.alert '无内容)\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(if-run (me.DOM.confirm \"确定添加？\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(array (extend v (array)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(me.DOM.value el \"\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\ttype ul\r\n\t\t\t\t\t\t\tchildren-type kvs\r\n\t\t\t\t\t\t\tchildren [\r\n\t\t\t\t\t\t\t\tarray 'array\r\n\t\t\t\t\t\t\t\trepeat {\r\n\t\t\t\t\t\t\t\t\t(let o args)\r\n\t\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\t\ttype li\r\n\t\t\t\t\t\t\t\t\t\tchildren [\r\n\t\t\t\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\t\t\t\ttype button text x \r\n\t\t\t\t\t\t\t\t\t\t\t\tevent [\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tclick {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(array (splice (array) o.index 1))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\t\t\t(str-join \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'o.index\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t------\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(o.data)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(str-join [共 (len (array)) 条记录])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t]\r\n\t\t\t\t]\r\n\t\t\t]\r\n\t\t}\r\n\t)\r\n}",
  "index/S-Lisp/index/s-html.lisp": "{\r\n\t(let \r\n\t\t(notice) args\r\n\t\trequire-factory (load '../util/require-factory.lisp)\r\n\t)\r\n\t(\r\n\t\t(require-factory \r\n\t\t\t`全局作用域`\r\n\t\t\t(kvs-extend 'mve mve base-scope)\r\n\t\t\t`局部处理`\r\n\t\t\t{\r\n\t\t\t\t(let (url success) args)\r\n\t\t\t\t(if-run (str-endsWith url \"s-html\")\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t(mve success)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsuccess\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t)\r\n\t\t`加载路径`\r\n\t\tindex-path\r\n\t\t`成功通知` \r\n\t\t{\r\n\t\t\t(apply notice args)\r\n\t\t}\r\n\t)\r\n}",
  "index/S-Lisp/util/require-factory.lisp": "\r\n\r\n\r\n{\r\n\t(let \r\n\t\t(scope doSuccess) args\r\n\t\tcaches (cache [])\r\n\t\tgetTxt {\r\n\t\t\t(js-call 'mb.ajax.require 'getTxt args)\r\n\t\t}\r\n\t\tcalUrl {\r\n\t\t\t(js-call 'mb.ajax.require 'calUrl \r\n\t \t\t\t(extend \r\n\t \t\t\t\t(js-call 'mb.ajax.require.cp 'baseUrl [])\r\n\t \t\t\t\targs\r\n\t \t\t\t)\r\n\t \t\t)\r\n\t\t}\r\n\t)\r\n\t{\r\n\t\t(let (url notice) args require this)\r\n\t\t(let value (kvs-find1st (caches) url))\r\n\t\t(if-run (exist? value)\r\n\t\t\t{\r\n\t\t\t\t(notice (first value))\r\n\t\t\t}\r\n\t\t\t{\r\n\t\t\t\t(getTxt url {\r\n\t\t\t\t\t(let \r\n\t\t\t\t\t\ttxt (str-join [\"[\"  (first args)  \"]\"] \" \")\r\n\t\t\t\t\t\tlib (cache [])\r\n\t\t\t\t\t\tscope (\r\n\t\t\t\t\t\t\tkvs-extend \"lib\" \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t(let (k) args)\r\n\t\t\t\t\t\t\t\t(kvs-find1st (lib) k)\r\n\t\t\t\t\t\t\t} \r\n\t\t\t\t\t\t\tscope\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\tbody (parse txt scope)\r\n\t\t\t\t\t\tsuccess (doSuccess url (kvs-find1st body 'success))\r\n\t\t\t\t\t\tdelay (default (kvs-find1st body 'delay) false)\r\n\t\t\t\t\t\tdata (kvs-find1st body 'data)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`先加载到池子中`\r\n\t\t\t\t\t(caches \r\n\t\t\t\t\t\t(kvs-extend \r\n\t\t\t\t\t\t\turl \r\n\t\t\t\t\t\t\t(list \r\n\t\t\t\t\t\t\t\t(if-run delay {(success)} {success})\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t(caches)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t`递归加载库引用`\r\n\t\t\t\t\t(async-kvs-reduce\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t`success`\r\n\t\t\t\t\t\t\t(lib (first args))\r\n\t\t\t\t\t\t\t(notice success)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t \tdata\r\n\t\t\t\t\t \t{\r\n\t\t\t\t\t \t\t(let (notice init v k) args)\r\n\t\t\t\t\t \t\t(require (calUrl url v){\r\n\t\t\t\t\t \t\t\t(notice\r\n\t\t\t\t\t \t\t\t\t(kvs-extend k (first args) init)\r\n\t\t\t\t\t \t\t\t)\r\n\t\t\t\t\t \t\t})\r\n\t\t\t\t\t \t}\r\n\t\t\t\t\t \t[]\r\n\t\t\t\t\t)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}"
}